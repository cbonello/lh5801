// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'instruction_tables.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$InstructionCategoryTearOff {
  const _$InstructionCategoryTearOff();

// ignore: unused_element
  _Illegal illegal() {
    return const _Illegal();
  }

// ignore: unused_element
  _LogicalOperation logicalOperation() {
    return const _LogicalOperation();
  }

// ignore: unused_element
  _ComparisonBitTest comparisonBitTest() {
    return const _ComparisonBitTest();
  }

// ignore: unused_element
  _LoadStore loadStore() {
    return const _LoadStore();
  }

// ignore: unused_element
  _BlockTransferSearch blockTransferSearch() {
    return const _BlockTransferSearch();
  }

// ignore: unused_element
  _InputOutput inputOutput() {
    return const _InputOutput();
  }

// ignore: unused_element
  _Branch branch() {
    return const _Branch();
  }

// ignore: unused_element
  _Jump jump() {
    return const _Jump();
  }

// ignore: unused_element
  _Lop lop() {
    return const _Lop();
  }

// ignore: unused_element
  _Call call() {
    return const _Call();
  }

// ignore: unused_element
  _Return ret() {
    return const _Return();
  }
}

// ignore: unused_element
const $InstructionCategory = _$InstructionCategoryTearOff();

mixin _$InstructionCategory {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  });
}

abstract class $InstructionCategoryCopyWith<$Res> {
  factory $InstructionCategoryCopyWith(
          InstructionCategory value, $Res Function(InstructionCategory) then) =
      _$InstructionCategoryCopyWithImpl<$Res>;
}

class _$InstructionCategoryCopyWithImpl<$Res>
    implements $InstructionCategoryCopyWith<$Res> {
  _$InstructionCategoryCopyWithImpl(this._value, this._then);

  final InstructionCategory _value;
  // ignore: unused_field
  final $Res Function(InstructionCategory) _then;
}

abstract class _$IllegalCopyWith<$Res> {
  factory _$IllegalCopyWith(_Illegal value, $Res Function(_Illegal) then) =
      __$IllegalCopyWithImpl<$Res>;
}

class __$IllegalCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$IllegalCopyWith<$Res> {
  __$IllegalCopyWithImpl(_Illegal _value, $Res Function(_Illegal) _then)
      : super(_value, (v) => _then(v as _Illegal));

  @override
  _Illegal get _value => super._value as _Illegal;
}

class _$_Illegal implements _Illegal {
  const _$_Illegal();

  @override
  String toString() {
    return 'InstructionCategory.illegal()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Illegal);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return illegal();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (illegal != null) {
      return illegal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return illegal(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (illegal != null) {
      return illegal(this);
    }
    return orElse();
  }
}

abstract class _Illegal implements InstructionCategory {
  const factory _Illegal() = _$_Illegal;
}

abstract class _$LogicalOperationCopyWith<$Res> {
  factory _$LogicalOperationCopyWith(
          _LogicalOperation value, $Res Function(_LogicalOperation) then) =
      __$LogicalOperationCopyWithImpl<$Res>;
}

class __$LogicalOperationCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$LogicalOperationCopyWith<$Res> {
  __$LogicalOperationCopyWithImpl(
      _LogicalOperation _value, $Res Function(_LogicalOperation) _then)
      : super(_value, (v) => _then(v as _LogicalOperation));

  @override
  _LogicalOperation get _value => super._value as _LogicalOperation;
}

class _$_LogicalOperation implements _LogicalOperation {
  const _$_LogicalOperation();

  @override
  String toString() {
    return 'InstructionCategory.logicalOperation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LogicalOperation);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return logicalOperation();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (logicalOperation != null) {
      return logicalOperation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return logicalOperation(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (logicalOperation != null) {
      return logicalOperation(this);
    }
    return orElse();
  }
}

abstract class _LogicalOperation implements InstructionCategory {
  const factory _LogicalOperation() = _$_LogicalOperation;
}

abstract class _$ComparisonBitTestCopyWith<$Res> {
  factory _$ComparisonBitTestCopyWith(
          _ComparisonBitTest value, $Res Function(_ComparisonBitTest) then) =
      __$ComparisonBitTestCopyWithImpl<$Res>;
}

class __$ComparisonBitTestCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$ComparisonBitTestCopyWith<$Res> {
  __$ComparisonBitTestCopyWithImpl(
      _ComparisonBitTest _value, $Res Function(_ComparisonBitTest) _then)
      : super(_value, (v) => _then(v as _ComparisonBitTest));

  @override
  _ComparisonBitTest get _value => super._value as _ComparisonBitTest;
}

class _$_ComparisonBitTest implements _ComparisonBitTest {
  const _$_ComparisonBitTest();

  @override
  String toString() {
    return 'InstructionCategory.comparisonBitTest()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ComparisonBitTest);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return comparisonBitTest();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (comparisonBitTest != null) {
      return comparisonBitTest();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return comparisonBitTest(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (comparisonBitTest != null) {
      return comparisonBitTest(this);
    }
    return orElse();
  }
}

abstract class _ComparisonBitTest implements InstructionCategory {
  const factory _ComparisonBitTest() = _$_ComparisonBitTest;
}

abstract class _$LoadStoreCopyWith<$Res> {
  factory _$LoadStoreCopyWith(
          _LoadStore value, $Res Function(_LoadStore) then) =
      __$LoadStoreCopyWithImpl<$Res>;
}

class __$LoadStoreCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$LoadStoreCopyWith<$Res> {
  __$LoadStoreCopyWithImpl(_LoadStore _value, $Res Function(_LoadStore) _then)
      : super(_value, (v) => _then(v as _LoadStore));

  @override
  _LoadStore get _value => super._value as _LoadStore;
}

class _$_LoadStore implements _LoadStore {
  const _$_LoadStore();

  @override
  String toString() {
    return 'InstructionCategory.loadStore()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LoadStore);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return loadStore();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadStore != null) {
      return loadStore();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return loadStore(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadStore != null) {
      return loadStore(this);
    }
    return orElse();
  }
}

abstract class _LoadStore implements InstructionCategory {
  const factory _LoadStore() = _$_LoadStore;
}

abstract class _$BlockTransferSearchCopyWith<$Res> {
  factory _$BlockTransferSearchCopyWith(_BlockTransferSearch value,
          $Res Function(_BlockTransferSearch) then) =
      __$BlockTransferSearchCopyWithImpl<$Res>;
}

class __$BlockTransferSearchCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$BlockTransferSearchCopyWith<$Res> {
  __$BlockTransferSearchCopyWithImpl(
      _BlockTransferSearch _value, $Res Function(_BlockTransferSearch) _then)
      : super(_value, (v) => _then(v as _BlockTransferSearch));

  @override
  _BlockTransferSearch get _value => super._value as _BlockTransferSearch;
}

class _$_BlockTransferSearch implements _BlockTransferSearch {
  const _$_BlockTransferSearch();

  @override
  String toString() {
    return 'InstructionCategory.blockTransferSearch()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BlockTransferSearch);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return blockTransferSearch();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (blockTransferSearch != null) {
      return blockTransferSearch();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return blockTransferSearch(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (blockTransferSearch != null) {
      return blockTransferSearch(this);
    }
    return orElse();
  }
}

abstract class _BlockTransferSearch implements InstructionCategory {
  const factory _BlockTransferSearch() = _$_BlockTransferSearch;
}

abstract class _$InputOutputCopyWith<$Res> {
  factory _$InputOutputCopyWith(
          _InputOutput value, $Res Function(_InputOutput) then) =
      __$InputOutputCopyWithImpl<$Res>;
}

class __$InputOutputCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$InputOutputCopyWith<$Res> {
  __$InputOutputCopyWithImpl(
      _InputOutput _value, $Res Function(_InputOutput) _then)
      : super(_value, (v) => _then(v as _InputOutput));

  @override
  _InputOutput get _value => super._value as _InputOutput;
}

class _$_InputOutput implements _InputOutput {
  const _$_InputOutput();

  @override
  String toString() {
    return 'InstructionCategory.inputOutput()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _InputOutput);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return inputOutput();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (inputOutput != null) {
      return inputOutput();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return inputOutput(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (inputOutput != null) {
      return inputOutput(this);
    }
    return orElse();
  }
}

abstract class _InputOutput implements InstructionCategory {
  const factory _InputOutput() = _$_InputOutput;
}

abstract class _$BranchCopyWith<$Res> {
  factory _$BranchCopyWith(_Branch value, $Res Function(_Branch) then) =
      __$BranchCopyWithImpl<$Res>;
}

class __$BranchCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$BranchCopyWith<$Res> {
  __$BranchCopyWithImpl(_Branch _value, $Res Function(_Branch) _then)
      : super(_value, (v) => _then(v as _Branch));

  @override
  _Branch get _value => super._value as _Branch;
}

class _$_Branch implements _Branch {
  const _$_Branch();

  @override
  String toString() {
    return 'InstructionCategory.branch()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Branch);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return branch();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (branch != null) {
      return branch();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return branch(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (branch != null) {
      return branch(this);
    }
    return orElse();
  }
}

abstract class _Branch implements InstructionCategory {
  const factory _Branch() = _$_Branch;
}

abstract class _$JumpCopyWith<$Res> {
  factory _$JumpCopyWith(_Jump value, $Res Function(_Jump) then) =
      __$JumpCopyWithImpl<$Res>;
}

class __$JumpCopyWithImpl<$Res> extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$JumpCopyWith<$Res> {
  __$JumpCopyWithImpl(_Jump _value, $Res Function(_Jump) _then)
      : super(_value, (v) => _then(v as _Jump));

  @override
  _Jump get _value => super._value as _Jump;
}

class _$_Jump implements _Jump {
  const _$_Jump();

  @override
  String toString() {
    return 'InstructionCategory.jump()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Jump);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return jump();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (jump != null) {
      return jump();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return jump(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (jump != null) {
      return jump(this);
    }
    return orElse();
  }
}

abstract class _Jump implements InstructionCategory {
  const factory _Jump() = _$_Jump;
}

abstract class _$LopCopyWith<$Res> {
  factory _$LopCopyWith(_Lop value, $Res Function(_Lop) then) =
      __$LopCopyWithImpl<$Res>;
}

class __$LopCopyWithImpl<$Res> extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$LopCopyWith<$Res> {
  __$LopCopyWithImpl(_Lop _value, $Res Function(_Lop) _then)
      : super(_value, (v) => _then(v as _Lop));

  @override
  _Lop get _value => super._value as _Lop;
}

class _$_Lop implements _Lop {
  const _$_Lop();

  @override
  String toString() {
    return 'InstructionCategory.lop()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Lop);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return lop();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (lop != null) {
      return lop();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return lop(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (lop != null) {
      return lop(this);
    }
    return orElse();
  }
}

abstract class _Lop implements InstructionCategory {
  const factory _Lop() = _$_Lop;
}

abstract class _$CallCopyWith<$Res> {
  factory _$CallCopyWith(_Call value, $Res Function(_Call) then) =
      __$CallCopyWithImpl<$Res>;
}

class __$CallCopyWithImpl<$Res> extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$CallCopyWith<$Res> {
  __$CallCopyWithImpl(_Call _value, $Res Function(_Call) _then)
      : super(_value, (v) => _then(v as _Call));

  @override
  _Call get _value => super._value as _Call;
}

class _$_Call implements _Call {
  const _$_Call();

  @override
  String toString() {
    return 'InstructionCategory.call()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Call);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return call();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (call != null) {
      return call();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return call(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (call != null) {
      return call(this);
    }
    return orElse();
  }
}

abstract class _Call implements InstructionCategory {
  const factory _Call() = _$_Call;
}

abstract class _$ReturnCopyWith<$Res> {
  factory _$ReturnCopyWith(_Return value, $Res Function(_Return) then) =
      __$ReturnCopyWithImpl<$Res>;
}

class __$ReturnCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$ReturnCopyWith<$Res> {
  __$ReturnCopyWithImpl(_Return _value, $Res Function(_Return) _then)
      : super(_value, (v) => _then(v as _Return));

  @override
  _Return get _value => super._value as _Return;
}

class _$_Return implements _Return {
  const _$_Return();

  @override
  String toString() {
    return 'InstructionCategory.ret()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Return);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return ret();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ret != null) {
      return ret();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return ret(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ret != null) {
      return ret(this);
    }
    return orElse();
  }
}

abstract class _Return implements InstructionCategory {
  const factory _Return() = _$_Return;
}

class _$OperandTearOff {
  const _$OperandTearOff();

// ignore: unused_element
  _None none() {
    return const _None();
  }

// ignore: unused_element
  _Reg reg(String registerName) {
    return _Reg(
      registerName,
    );
  }

// ignore: unused_element
  _Mem0Reg mem0Reg(String registerName) {
    return _Mem0Reg(
      registerName,
    );
  }

// ignore: unused_element
  _Mem0Imm16 mem0Imm16(int value) {
    return _Mem0Imm16(
      value,
    );
  }

// ignore: unused_element
  _Mem1Reg mem1Reg(String registerName) {
    return _Mem1Reg(
      registerName,
    );
  }

// ignore: unused_element
  _Mem1Imm16 mem1Imm16(int value) {
    return _Mem1Imm16(
      value,
    );
  }

// ignore: unused_element
  _Imm8 imm8(int value) {
    return _Imm8(
      value,
    );
  }

// ignore: unused_element
  _DispPlus dispPlus(int offset) {
    return _DispPlus(
      offset,
    );
  }

// ignore: unused_element
  _DispMinus dispMinus(int offset) {
    return _DispMinus(
      offset,
    );
  }

// ignore: unused_element
  _Mem0Cst8 mem0Cst8(int constant) {
    return _Mem0Cst8(
      constant,
    );
  }

// ignore: unused_element
  _Imm16 imm16(int value) {
    return _Imm16(
      value,
    );
  }
}

// ignore: unused_element
const $Operand = _$OperandTearOff();

mixin _$Operand {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(String registerName),
    @required Result mem0Reg(String registerName),
    @required Result mem0Imm16(int value),
    @required Result mem1Reg(String registerName),
    @required Result mem1Imm16(int value),
    @required Result imm8(int value),
    @required Result dispPlus(int offset),
    @required Result dispMinus(int offset),
    @required Result mem0Cst8(int constant),
    @required Result imm16(int value),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(String registerName),
    Result mem0Reg(String registerName),
    Result mem0Imm16(int value),
    Result mem1Reg(String registerName),
    Result mem1Imm16(int value),
    Result imm8(int value),
    Result dispPlus(int offset),
    Result dispMinus(int offset),
    Result mem0Cst8(int constant),
    Result imm16(int value),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Cst8(_Mem0Cst8 value),
    @required Result imm16(_Imm16 value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Cst8(_Mem0Cst8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  });
}

abstract class $OperandCopyWith<$Res> {
  factory $OperandCopyWith(Operand value, $Res Function(Operand) then) =
      _$OperandCopyWithImpl<$Res>;
}

class _$OperandCopyWithImpl<$Res> implements $OperandCopyWith<$Res> {
  _$OperandCopyWithImpl(this._value, this._then);

  final Operand _value;
  // ignore: unused_field
  final $Res Function(Operand) _then;
}

abstract class _$NoneCopyWith<$Res> {
  factory _$NoneCopyWith(_None value, $Res Function(_None) then) =
      __$NoneCopyWithImpl<$Res>;
}

class __$NoneCopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$NoneCopyWith<$Res> {
  __$NoneCopyWithImpl(_None _value, $Res Function(_None) _then)
      : super(_value, (v) => _then(v as _None));

  @override
  _None get _value => super._value as _None;
}

class _$_None extends _None {
  const _$_None() : super._();

  @override
  String toString() {
    return 'Operand.none()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _None);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(String registerName),
    @required Result mem0Reg(String registerName),
    @required Result mem0Imm16(int value),
    @required Result mem1Reg(String registerName),
    @required Result mem1Imm16(int value),
    @required Result imm8(int value),
    @required Result dispPlus(int offset),
    @required Result dispMinus(int offset),
    @required Result mem0Cst8(int constant),
    @required Result imm16(int value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return none();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(String registerName),
    Result mem0Reg(String registerName),
    Result mem0Imm16(int value),
    Result mem1Reg(String registerName),
    Result mem1Imm16(int value),
    Result imm8(int value),
    Result dispPlus(int offset),
    Result dispMinus(int offset),
    Result mem0Cst8(int constant),
    Result imm16(int value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Cst8(_Mem0Cst8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return none(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Cst8(_Mem0Cst8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class _None extends Operand {
  const _None._() : super._();
  const factory _None() = _$_None;
}

abstract class _$RegCopyWith<$Res> {
  factory _$RegCopyWith(_Reg value, $Res Function(_Reg) then) =
      __$RegCopyWithImpl<$Res>;
  $Res call({String registerName});
}

class __$RegCopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$RegCopyWith<$Res> {
  __$RegCopyWithImpl(_Reg _value, $Res Function(_Reg) _then)
      : super(_value, (v) => _then(v as _Reg));

  @override
  _Reg get _value => super._value as _Reg;

  @override
  $Res call({
    Object registerName = freezed,
  }) {
    return _then(_Reg(
      registerName == freezed ? _value.registerName : registerName as String,
    ));
  }
}

class _$_Reg extends _Reg {
  const _$_Reg(this.registerName)
      : assert(registerName != null),
        super._();

  @override
  final String registerName;

  @override
  String toString() {
    return 'Operand.reg(registerName: $registerName)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Reg &&
            (identical(other.registerName, registerName) ||
                const DeepCollectionEquality()
                    .equals(other.registerName, registerName)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(registerName);

  @override
  _$RegCopyWith<_Reg> get copyWith =>
      __$RegCopyWithImpl<_Reg>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(String registerName),
    @required Result mem0Reg(String registerName),
    @required Result mem0Imm16(int value),
    @required Result mem1Reg(String registerName),
    @required Result mem1Imm16(int value),
    @required Result imm8(int value),
    @required Result dispPlus(int offset),
    @required Result dispMinus(int offset),
    @required Result mem0Cst8(int constant),
    @required Result imm16(int value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return reg(registerName);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(String registerName),
    Result mem0Reg(String registerName),
    Result mem0Imm16(int value),
    Result mem1Reg(String registerName),
    Result mem1Imm16(int value),
    Result imm8(int value),
    Result dispPlus(int offset),
    Result dispMinus(int offset),
    Result mem0Cst8(int constant),
    Result imm16(int value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (reg != null) {
      return reg(registerName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Cst8(_Mem0Cst8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return reg(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Cst8(_Mem0Cst8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (reg != null) {
      return reg(this);
    }
    return orElse();
  }
}

abstract class _Reg extends Operand {
  const _Reg._() : super._();
  const factory _Reg(String registerName) = _$_Reg;

  String get registerName;
  _$RegCopyWith<_Reg> get copyWith;
}

abstract class _$Mem0RegCopyWith<$Res> {
  factory _$Mem0RegCopyWith(_Mem0Reg value, $Res Function(_Mem0Reg) then) =
      __$Mem0RegCopyWithImpl<$Res>;
  $Res call({String registerName});
}

class __$Mem0RegCopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$Mem0RegCopyWith<$Res> {
  __$Mem0RegCopyWithImpl(_Mem0Reg _value, $Res Function(_Mem0Reg) _then)
      : super(_value, (v) => _then(v as _Mem0Reg));

  @override
  _Mem0Reg get _value => super._value as _Mem0Reg;

  @override
  $Res call({
    Object registerName = freezed,
  }) {
    return _then(_Mem0Reg(
      registerName == freezed ? _value.registerName : registerName as String,
    ));
  }
}

class _$_Mem0Reg extends _Mem0Reg {
  const _$_Mem0Reg(this.registerName)
      : assert(registerName != null),
        super._();

  @override
  final String registerName;

  @override
  String toString() {
    return 'Operand.mem0Reg(registerName: $registerName)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Mem0Reg &&
            (identical(other.registerName, registerName) ||
                const DeepCollectionEquality()
                    .equals(other.registerName, registerName)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(registerName);

  @override
  _$Mem0RegCopyWith<_Mem0Reg> get copyWith =>
      __$Mem0RegCopyWithImpl<_Mem0Reg>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(String registerName),
    @required Result mem0Reg(String registerName),
    @required Result mem0Imm16(int value),
    @required Result mem1Reg(String registerName),
    @required Result mem1Imm16(int value),
    @required Result imm8(int value),
    @required Result dispPlus(int offset),
    @required Result dispMinus(int offset),
    @required Result mem0Cst8(int constant),
    @required Result imm16(int value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return mem0Reg(registerName);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(String registerName),
    Result mem0Reg(String registerName),
    Result mem0Imm16(int value),
    Result mem1Reg(String registerName),
    Result mem1Imm16(int value),
    Result imm8(int value),
    Result dispPlus(int offset),
    Result dispMinus(int offset),
    Result mem0Cst8(int constant),
    Result imm16(int value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem0Reg != null) {
      return mem0Reg(registerName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Cst8(_Mem0Cst8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return mem0Reg(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Cst8(_Mem0Cst8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem0Reg != null) {
      return mem0Reg(this);
    }
    return orElse();
  }
}

abstract class _Mem0Reg extends Operand {
  const _Mem0Reg._() : super._();
  const factory _Mem0Reg(String registerName) = _$_Mem0Reg;

  String get registerName;
  _$Mem0RegCopyWith<_Mem0Reg> get copyWith;
}

abstract class _$Mem0Imm16CopyWith<$Res> {
  factory _$Mem0Imm16CopyWith(
          _Mem0Imm16 value, $Res Function(_Mem0Imm16) then) =
      __$Mem0Imm16CopyWithImpl<$Res>;
  $Res call({int value});
}

class __$Mem0Imm16CopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$Mem0Imm16CopyWith<$Res> {
  __$Mem0Imm16CopyWithImpl(_Mem0Imm16 _value, $Res Function(_Mem0Imm16) _then)
      : super(_value, (v) => _then(v as _Mem0Imm16));

  @override
  _Mem0Imm16 get _value => super._value as _Mem0Imm16;

  @override
  $Res call({
    Object value = freezed,
  }) {
    return _then(_Mem0Imm16(
      value == freezed ? _value.value : value as int,
    ));
  }
}

class _$_Mem0Imm16 extends _Mem0Imm16 {
  const _$_Mem0Imm16(this.value)
      : assert(value != null),
        super._();

  @override
  final int value;

  @override
  String toString() {
    return 'Operand.mem0Imm16(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Mem0Imm16 &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(value);

  @override
  _$Mem0Imm16CopyWith<_Mem0Imm16> get copyWith =>
      __$Mem0Imm16CopyWithImpl<_Mem0Imm16>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(String registerName),
    @required Result mem0Reg(String registerName),
    @required Result mem0Imm16(int value),
    @required Result mem1Reg(String registerName),
    @required Result mem1Imm16(int value),
    @required Result imm8(int value),
    @required Result dispPlus(int offset),
    @required Result dispMinus(int offset),
    @required Result mem0Cst8(int constant),
    @required Result imm16(int value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return mem0Imm16(value);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(String registerName),
    Result mem0Reg(String registerName),
    Result mem0Imm16(int value),
    Result mem1Reg(String registerName),
    Result mem1Imm16(int value),
    Result imm8(int value),
    Result dispPlus(int offset),
    Result dispMinus(int offset),
    Result mem0Cst8(int constant),
    Result imm16(int value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem0Imm16 != null) {
      return mem0Imm16(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Cst8(_Mem0Cst8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return mem0Imm16(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Cst8(_Mem0Cst8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem0Imm16 != null) {
      return mem0Imm16(this);
    }
    return orElse();
  }
}

abstract class _Mem0Imm16 extends Operand {
  const _Mem0Imm16._() : super._();
  const factory _Mem0Imm16(int value) = _$_Mem0Imm16;

  int get value;
  _$Mem0Imm16CopyWith<_Mem0Imm16> get copyWith;
}

abstract class _$Mem1RegCopyWith<$Res> {
  factory _$Mem1RegCopyWith(_Mem1Reg value, $Res Function(_Mem1Reg) then) =
      __$Mem1RegCopyWithImpl<$Res>;
  $Res call({String registerName});
}

class __$Mem1RegCopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$Mem1RegCopyWith<$Res> {
  __$Mem1RegCopyWithImpl(_Mem1Reg _value, $Res Function(_Mem1Reg) _then)
      : super(_value, (v) => _then(v as _Mem1Reg));

  @override
  _Mem1Reg get _value => super._value as _Mem1Reg;

  @override
  $Res call({
    Object registerName = freezed,
  }) {
    return _then(_Mem1Reg(
      registerName == freezed ? _value.registerName : registerName as String,
    ));
  }
}

class _$_Mem1Reg extends _Mem1Reg {
  const _$_Mem1Reg(this.registerName)
      : assert(registerName != null),
        super._();

  @override
  final String registerName;

  @override
  String toString() {
    return 'Operand.mem1Reg(registerName: $registerName)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Mem1Reg &&
            (identical(other.registerName, registerName) ||
                const DeepCollectionEquality()
                    .equals(other.registerName, registerName)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(registerName);

  @override
  _$Mem1RegCopyWith<_Mem1Reg> get copyWith =>
      __$Mem1RegCopyWithImpl<_Mem1Reg>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(String registerName),
    @required Result mem0Reg(String registerName),
    @required Result mem0Imm16(int value),
    @required Result mem1Reg(String registerName),
    @required Result mem1Imm16(int value),
    @required Result imm8(int value),
    @required Result dispPlus(int offset),
    @required Result dispMinus(int offset),
    @required Result mem0Cst8(int constant),
    @required Result imm16(int value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return mem1Reg(registerName);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(String registerName),
    Result mem0Reg(String registerName),
    Result mem0Imm16(int value),
    Result mem1Reg(String registerName),
    Result mem1Imm16(int value),
    Result imm8(int value),
    Result dispPlus(int offset),
    Result dispMinus(int offset),
    Result mem0Cst8(int constant),
    Result imm16(int value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem1Reg != null) {
      return mem1Reg(registerName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Cst8(_Mem0Cst8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return mem1Reg(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Cst8(_Mem0Cst8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem1Reg != null) {
      return mem1Reg(this);
    }
    return orElse();
  }
}

abstract class _Mem1Reg extends Operand {
  const _Mem1Reg._() : super._();
  const factory _Mem1Reg(String registerName) = _$_Mem1Reg;

  String get registerName;
  _$Mem1RegCopyWith<_Mem1Reg> get copyWith;
}

abstract class _$Mem1Imm16CopyWith<$Res> {
  factory _$Mem1Imm16CopyWith(
          _Mem1Imm16 value, $Res Function(_Mem1Imm16) then) =
      __$Mem1Imm16CopyWithImpl<$Res>;
  $Res call({int value});
}

class __$Mem1Imm16CopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$Mem1Imm16CopyWith<$Res> {
  __$Mem1Imm16CopyWithImpl(_Mem1Imm16 _value, $Res Function(_Mem1Imm16) _then)
      : super(_value, (v) => _then(v as _Mem1Imm16));

  @override
  _Mem1Imm16 get _value => super._value as _Mem1Imm16;

  @override
  $Res call({
    Object value = freezed,
  }) {
    return _then(_Mem1Imm16(
      value == freezed ? _value.value : value as int,
    ));
  }
}

class _$_Mem1Imm16 extends _Mem1Imm16 {
  const _$_Mem1Imm16(this.value)
      : assert(value != null),
        super._();

  @override
  final int value;

  @override
  String toString() {
    return 'Operand.mem1Imm16(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Mem1Imm16 &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(value);

  @override
  _$Mem1Imm16CopyWith<_Mem1Imm16> get copyWith =>
      __$Mem1Imm16CopyWithImpl<_Mem1Imm16>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(String registerName),
    @required Result mem0Reg(String registerName),
    @required Result mem0Imm16(int value),
    @required Result mem1Reg(String registerName),
    @required Result mem1Imm16(int value),
    @required Result imm8(int value),
    @required Result dispPlus(int offset),
    @required Result dispMinus(int offset),
    @required Result mem0Cst8(int constant),
    @required Result imm16(int value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return mem1Imm16(value);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(String registerName),
    Result mem0Reg(String registerName),
    Result mem0Imm16(int value),
    Result mem1Reg(String registerName),
    Result mem1Imm16(int value),
    Result imm8(int value),
    Result dispPlus(int offset),
    Result dispMinus(int offset),
    Result mem0Cst8(int constant),
    Result imm16(int value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem1Imm16 != null) {
      return mem1Imm16(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Cst8(_Mem0Cst8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return mem1Imm16(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Cst8(_Mem0Cst8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem1Imm16 != null) {
      return mem1Imm16(this);
    }
    return orElse();
  }
}

abstract class _Mem1Imm16 extends Operand {
  const _Mem1Imm16._() : super._();
  const factory _Mem1Imm16(int value) = _$_Mem1Imm16;

  int get value;
  _$Mem1Imm16CopyWith<_Mem1Imm16> get copyWith;
}

abstract class _$Imm8CopyWith<$Res> {
  factory _$Imm8CopyWith(_Imm8 value, $Res Function(_Imm8) then) =
      __$Imm8CopyWithImpl<$Res>;
  $Res call({int value});
}

class __$Imm8CopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$Imm8CopyWith<$Res> {
  __$Imm8CopyWithImpl(_Imm8 _value, $Res Function(_Imm8) _then)
      : super(_value, (v) => _then(v as _Imm8));

  @override
  _Imm8 get _value => super._value as _Imm8;

  @override
  $Res call({
    Object value = freezed,
  }) {
    return _then(_Imm8(
      value == freezed ? _value.value : value as int,
    ));
  }
}

class _$_Imm8 extends _Imm8 {
  const _$_Imm8(this.value)
      : assert(value != null),
        super._();

  @override
  final int value;

  @override
  String toString() {
    return 'Operand.imm8(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Imm8 &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(value);

  @override
  _$Imm8CopyWith<_Imm8> get copyWith =>
      __$Imm8CopyWithImpl<_Imm8>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(String registerName),
    @required Result mem0Reg(String registerName),
    @required Result mem0Imm16(int value),
    @required Result mem1Reg(String registerName),
    @required Result mem1Imm16(int value),
    @required Result imm8(int value),
    @required Result dispPlus(int offset),
    @required Result dispMinus(int offset),
    @required Result mem0Cst8(int constant),
    @required Result imm16(int value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return imm8(value);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(String registerName),
    Result mem0Reg(String registerName),
    Result mem0Imm16(int value),
    Result mem1Reg(String registerName),
    Result mem1Imm16(int value),
    Result imm8(int value),
    Result dispPlus(int offset),
    Result dispMinus(int offset),
    Result mem0Cst8(int constant),
    Result imm16(int value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (imm8 != null) {
      return imm8(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Cst8(_Mem0Cst8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return imm8(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Cst8(_Mem0Cst8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (imm8 != null) {
      return imm8(this);
    }
    return orElse();
  }
}

abstract class _Imm8 extends Operand {
  const _Imm8._() : super._();
  const factory _Imm8(int value) = _$_Imm8;

  int get value;
  _$Imm8CopyWith<_Imm8> get copyWith;
}

abstract class _$DispPlusCopyWith<$Res> {
  factory _$DispPlusCopyWith(_DispPlus value, $Res Function(_DispPlus) then) =
      __$DispPlusCopyWithImpl<$Res>;
  $Res call({int offset});
}

class __$DispPlusCopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$DispPlusCopyWith<$Res> {
  __$DispPlusCopyWithImpl(_DispPlus _value, $Res Function(_DispPlus) _then)
      : super(_value, (v) => _then(v as _DispPlus));

  @override
  _DispPlus get _value => super._value as _DispPlus;

  @override
  $Res call({
    Object offset = freezed,
  }) {
    return _then(_DispPlus(
      offset == freezed ? _value.offset : offset as int,
    ));
  }
}

class _$_DispPlus extends _DispPlus {
  const _$_DispPlus(this.offset)
      : assert(offset != null),
        super._();

  @override
  final int offset;

  @override
  String toString() {
    return 'Operand.dispPlus(offset: $offset)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DispPlus &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(offset);

  @override
  _$DispPlusCopyWith<_DispPlus> get copyWith =>
      __$DispPlusCopyWithImpl<_DispPlus>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(String registerName),
    @required Result mem0Reg(String registerName),
    @required Result mem0Imm16(int value),
    @required Result mem1Reg(String registerName),
    @required Result mem1Imm16(int value),
    @required Result imm8(int value),
    @required Result dispPlus(int offset),
    @required Result dispMinus(int offset),
    @required Result mem0Cst8(int constant),
    @required Result imm16(int value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return dispPlus(offset);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(String registerName),
    Result mem0Reg(String registerName),
    Result mem0Imm16(int value),
    Result mem1Reg(String registerName),
    Result mem1Imm16(int value),
    Result imm8(int value),
    Result dispPlus(int offset),
    Result dispMinus(int offset),
    Result mem0Cst8(int constant),
    Result imm16(int value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (dispPlus != null) {
      return dispPlus(offset);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Cst8(_Mem0Cst8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return dispPlus(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Cst8(_Mem0Cst8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (dispPlus != null) {
      return dispPlus(this);
    }
    return orElse();
  }
}

abstract class _DispPlus extends Operand {
  const _DispPlus._() : super._();
  const factory _DispPlus(int offset) = _$_DispPlus;

  int get offset;
  _$DispPlusCopyWith<_DispPlus> get copyWith;
}

abstract class _$DispMinusCopyWith<$Res> {
  factory _$DispMinusCopyWith(
          _DispMinus value, $Res Function(_DispMinus) then) =
      __$DispMinusCopyWithImpl<$Res>;
  $Res call({int offset});
}

class __$DispMinusCopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$DispMinusCopyWith<$Res> {
  __$DispMinusCopyWithImpl(_DispMinus _value, $Res Function(_DispMinus) _then)
      : super(_value, (v) => _then(v as _DispMinus));

  @override
  _DispMinus get _value => super._value as _DispMinus;

  @override
  $Res call({
    Object offset = freezed,
  }) {
    return _then(_DispMinus(
      offset == freezed ? _value.offset : offset as int,
    ));
  }
}

class _$_DispMinus extends _DispMinus {
  const _$_DispMinus(this.offset)
      : assert(offset != null),
        super._();

  @override
  final int offset;

  @override
  String toString() {
    return 'Operand.dispMinus(offset: $offset)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DispMinus &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(offset);

  @override
  _$DispMinusCopyWith<_DispMinus> get copyWith =>
      __$DispMinusCopyWithImpl<_DispMinus>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(String registerName),
    @required Result mem0Reg(String registerName),
    @required Result mem0Imm16(int value),
    @required Result mem1Reg(String registerName),
    @required Result mem1Imm16(int value),
    @required Result imm8(int value),
    @required Result dispPlus(int offset),
    @required Result dispMinus(int offset),
    @required Result mem0Cst8(int constant),
    @required Result imm16(int value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return dispMinus(offset);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(String registerName),
    Result mem0Reg(String registerName),
    Result mem0Imm16(int value),
    Result mem1Reg(String registerName),
    Result mem1Imm16(int value),
    Result imm8(int value),
    Result dispPlus(int offset),
    Result dispMinus(int offset),
    Result mem0Cst8(int constant),
    Result imm16(int value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (dispMinus != null) {
      return dispMinus(offset);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Cst8(_Mem0Cst8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return dispMinus(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Cst8(_Mem0Cst8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (dispMinus != null) {
      return dispMinus(this);
    }
    return orElse();
  }
}

abstract class _DispMinus extends Operand {
  const _DispMinus._() : super._();
  const factory _DispMinus(int offset) = _$_DispMinus;

  int get offset;
  _$DispMinusCopyWith<_DispMinus> get copyWith;
}

abstract class _$Mem0Cst8CopyWith<$Res> {
  factory _$Mem0Cst8CopyWith(_Mem0Cst8 value, $Res Function(_Mem0Cst8) then) =
      __$Mem0Cst8CopyWithImpl<$Res>;
  $Res call({int constant});
}

class __$Mem0Cst8CopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$Mem0Cst8CopyWith<$Res> {
  __$Mem0Cst8CopyWithImpl(_Mem0Cst8 _value, $Res Function(_Mem0Cst8) _then)
      : super(_value, (v) => _then(v as _Mem0Cst8));

  @override
  _Mem0Cst8 get _value => super._value as _Mem0Cst8;

  @override
  $Res call({
    Object constant = freezed,
  }) {
    return _then(_Mem0Cst8(
      constant == freezed ? _value.constant : constant as int,
    ));
  }
}

class _$_Mem0Cst8 extends _Mem0Cst8 {
  const _$_Mem0Cst8(this.constant)
      : assert(constant != null),
        super._();

  @override
  final int constant;

  @override
  String toString() {
    return 'Operand.mem0Cst8(constant: $constant)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Mem0Cst8 &&
            (identical(other.constant, constant) ||
                const DeepCollectionEquality()
                    .equals(other.constant, constant)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(constant);

  @override
  _$Mem0Cst8CopyWith<_Mem0Cst8> get copyWith =>
      __$Mem0Cst8CopyWithImpl<_Mem0Cst8>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(String registerName),
    @required Result mem0Reg(String registerName),
    @required Result mem0Imm16(int value),
    @required Result mem1Reg(String registerName),
    @required Result mem1Imm16(int value),
    @required Result imm8(int value),
    @required Result dispPlus(int offset),
    @required Result dispMinus(int offset),
    @required Result mem0Cst8(int constant),
    @required Result imm16(int value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return mem0Cst8(constant);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(String registerName),
    Result mem0Reg(String registerName),
    Result mem0Imm16(int value),
    Result mem1Reg(String registerName),
    Result mem1Imm16(int value),
    Result imm8(int value),
    Result dispPlus(int offset),
    Result dispMinus(int offset),
    Result mem0Cst8(int constant),
    Result imm16(int value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem0Cst8 != null) {
      return mem0Cst8(constant);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Cst8(_Mem0Cst8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return mem0Cst8(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Cst8(_Mem0Cst8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem0Cst8 != null) {
      return mem0Cst8(this);
    }
    return orElse();
  }
}

abstract class _Mem0Cst8 extends Operand {
  const _Mem0Cst8._() : super._();
  const factory _Mem0Cst8(int constant) = _$_Mem0Cst8;

  int get constant;
  _$Mem0Cst8CopyWith<_Mem0Cst8> get copyWith;
}

abstract class _$Imm16CopyWith<$Res> {
  factory _$Imm16CopyWith(_Imm16 value, $Res Function(_Imm16) then) =
      __$Imm16CopyWithImpl<$Res>;
  $Res call({int value});
}

class __$Imm16CopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$Imm16CopyWith<$Res> {
  __$Imm16CopyWithImpl(_Imm16 _value, $Res Function(_Imm16) _then)
      : super(_value, (v) => _then(v as _Imm16));

  @override
  _Imm16 get _value => super._value as _Imm16;

  @override
  $Res call({
    Object value = freezed,
  }) {
    return _then(_Imm16(
      value == freezed ? _value.value : value as int,
    ));
  }
}

class _$_Imm16 extends _Imm16 {
  const _$_Imm16(this.value)
      : assert(value != null),
        super._();

  @override
  final int value;

  @override
  String toString() {
    return 'Operand.imm16(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Imm16 &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(value);

  @override
  _$Imm16CopyWith<_Imm16> get copyWith =>
      __$Imm16CopyWithImpl<_Imm16>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(String registerName),
    @required Result mem0Reg(String registerName),
    @required Result mem0Imm16(int value),
    @required Result mem1Reg(String registerName),
    @required Result mem1Imm16(int value),
    @required Result imm8(int value),
    @required Result dispPlus(int offset),
    @required Result dispMinus(int offset),
    @required Result mem0Cst8(int constant),
    @required Result imm16(int value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return imm16(value);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(String registerName),
    Result mem0Reg(String registerName),
    Result mem0Imm16(int value),
    Result mem1Reg(String registerName),
    Result mem1Imm16(int value),
    Result imm8(int value),
    Result dispPlus(int offset),
    Result dispMinus(int offset),
    Result mem0Cst8(int constant),
    Result imm16(int value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (imm16 != null) {
      return imm16(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Cst8(_Mem0Cst8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Cst8 != null);
    assert(imm16 != null);
    return imm16(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Cst8(_Mem0Cst8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (imm16 != null) {
      return imm16(this);
    }
    return orElse();
  }
}

abstract class _Imm16 extends Operand {
  const _Imm16._() : super._();
  const factory _Imm16(int value) = _$_Imm16;

  int get value;
  _$Imm16CopyWith<_Imm16> get copyWith;
}
