// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'instruction_tables.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$InstructionCategoryTearOff {
  const _$InstructionCategoryTearOff();

  _Illegal illegal() {
    return const _Illegal();
  }

  _LogicalOperation logicalOperation() {
    return const _LogicalOperation();
  }

  _ComparisonBitTest comparisonBitTest() {
    return const _ComparisonBitTest();
  }

  _LoadStore loadStore() {
    return const _LoadStore();
  }

  _BlockTransferSearch blockTransferSearch() {
    return const _BlockTransferSearch();
  }

  _InputOutput inputOutput() {
    return const _InputOutput();
  }

  _Branch branch() {
    return const _Branch();
  }

  _Jump jump() {
    return const _Jump();
  }

  _Lop lop() {
    return const _Lop();
  }

  _Call call() {
    return const _Call();
  }

  _Return ret() {
    return const _Return();
  }
}

/// @nodoc
const $InstructionCategory = _$InstructionCategoryTearOff();

/// @nodoc
mixin _$InstructionCategory {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() illegal,
    required TResult Function() logicalOperation,
    required TResult Function() comparisonBitTest,
    required TResult Function() loadStore,
    required TResult Function() blockTransferSearch,
    required TResult Function() inputOutput,
    required TResult Function() branch,
    required TResult Function() jump,
    required TResult Function() lop,
    required TResult Function() call,
    required TResult Function() ret,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? illegal,
    TResult Function()? logicalOperation,
    TResult Function()? comparisonBitTest,
    TResult Function()? loadStore,
    TResult Function()? blockTransferSearch,
    TResult Function()? inputOutput,
    TResult Function()? branch,
    TResult Function()? jump,
    TResult Function()? lop,
    TResult Function()? call,
    TResult Function()? ret,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Illegal value) illegal,
    required TResult Function(_LogicalOperation value) logicalOperation,
    required TResult Function(_ComparisonBitTest value) comparisonBitTest,
    required TResult Function(_LoadStore value) loadStore,
    required TResult Function(_BlockTransferSearch value) blockTransferSearch,
    required TResult Function(_InputOutput value) inputOutput,
    required TResult Function(_Branch value) branch,
    required TResult Function(_Jump value) jump,
    required TResult Function(_Lop value) lop,
    required TResult Function(_Call value) call,
    required TResult Function(_Return value) ret,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Illegal value)? illegal,
    TResult Function(_LogicalOperation value)? logicalOperation,
    TResult Function(_ComparisonBitTest value)? comparisonBitTest,
    TResult Function(_LoadStore value)? loadStore,
    TResult Function(_BlockTransferSearch value)? blockTransferSearch,
    TResult Function(_InputOutput value)? inputOutput,
    TResult Function(_Branch value)? branch,
    TResult Function(_Jump value)? jump,
    TResult Function(_Lop value)? lop,
    TResult Function(_Call value)? call,
    TResult Function(_Return value)? ret,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $InstructionCategoryCopyWith<$Res> {
  factory $InstructionCategoryCopyWith(
          InstructionCategory value, $Res Function(InstructionCategory) then) =
      _$InstructionCategoryCopyWithImpl<$Res>;
}

/// @nodoc
class _$InstructionCategoryCopyWithImpl<$Res>
    implements $InstructionCategoryCopyWith<$Res> {
  _$InstructionCategoryCopyWithImpl(this._value, this._then);

  final InstructionCategory _value;
  // ignore: unused_field
  final $Res Function(InstructionCategory) _then;
}

/// @nodoc
abstract class _$IllegalCopyWith<$Res> {
  factory _$IllegalCopyWith(_Illegal value, $Res Function(_Illegal) then) =
      __$IllegalCopyWithImpl<$Res>;
}

/// @nodoc
class __$IllegalCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$IllegalCopyWith<$Res> {
  __$IllegalCopyWithImpl(_Illegal _value, $Res Function(_Illegal) _then)
      : super(_value, (v) => _then(v as _Illegal));

  @override
  _Illegal get _value => super._value as _Illegal;
}

/// @nodoc

class _$_Illegal implements _Illegal {
  const _$_Illegal();

  @override
  String toString() {
    return 'InstructionCategory.illegal()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Illegal);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() illegal,
    required TResult Function() logicalOperation,
    required TResult Function() comparisonBitTest,
    required TResult Function() loadStore,
    required TResult Function() blockTransferSearch,
    required TResult Function() inputOutput,
    required TResult Function() branch,
    required TResult Function() jump,
    required TResult Function() lop,
    required TResult Function() call,
    required TResult Function() ret,
  }) {
    return illegal();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? illegal,
    TResult Function()? logicalOperation,
    TResult Function()? comparisonBitTest,
    TResult Function()? loadStore,
    TResult Function()? blockTransferSearch,
    TResult Function()? inputOutput,
    TResult Function()? branch,
    TResult Function()? jump,
    TResult Function()? lop,
    TResult Function()? call,
    TResult Function()? ret,
    required TResult orElse(),
  }) {
    if (illegal != null) {
      return illegal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Illegal value) illegal,
    required TResult Function(_LogicalOperation value) logicalOperation,
    required TResult Function(_ComparisonBitTest value) comparisonBitTest,
    required TResult Function(_LoadStore value) loadStore,
    required TResult Function(_BlockTransferSearch value) blockTransferSearch,
    required TResult Function(_InputOutput value) inputOutput,
    required TResult Function(_Branch value) branch,
    required TResult Function(_Jump value) jump,
    required TResult Function(_Lop value) lop,
    required TResult Function(_Call value) call,
    required TResult Function(_Return value) ret,
  }) {
    return illegal(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Illegal value)? illegal,
    TResult Function(_LogicalOperation value)? logicalOperation,
    TResult Function(_ComparisonBitTest value)? comparisonBitTest,
    TResult Function(_LoadStore value)? loadStore,
    TResult Function(_BlockTransferSearch value)? blockTransferSearch,
    TResult Function(_InputOutput value)? inputOutput,
    TResult Function(_Branch value)? branch,
    TResult Function(_Jump value)? jump,
    TResult Function(_Lop value)? lop,
    TResult Function(_Call value)? call,
    TResult Function(_Return value)? ret,
    required TResult orElse(),
  }) {
    if (illegal != null) {
      return illegal(this);
    }
    return orElse();
  }
}

abstract class _Illegal implements InstructionCategory {
  const factory _Illegal() = _$_Illegal;
}

/// @nodoc
abstract class _$LogicalOperationCopyWith<$Res> {
  factory _$LogicalOperationCopyWith(
          _LogicalOperation value, $Res Function(_LogicalOperation) then) =
      __$LogicalOperationCopyWithImpl<$Res>;
}

/// @nodoc
class __$LogicalOperationCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$LogicalOperationCopyWith<$Res> {
  __$LogicalOperationCopyWithImpl(
      _LogicalOperation _value, $Res Function(_LogicalOperation) _then)
      : super(_value, (v) => _then(v as _LogicalOperation));

  @override
  _LogicalOperation get _value => super._value as _LogicalOperation;
}

/// @nodoc

class _$_LogicalOperation implements _LogicalOperation {
  const _$_LogicalOperation();

  @override
  String toString() {
    return 'InstructionCategory.logicalOperation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LogicalOperation);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() illegal,
    required TResult Function() logicalOperation,
    required TResult Function() comparisonBitTest,
    required TResult Function() loadStore,
    required TResult Function() blockTransferSearch,
    required TResult Function() inputOutput,
    required TResult Function() branch,
    required TResult Function() jump,
    required TResult Function() lop,
    required TResult Function() call,
    required TResult Function() ret,
  }) {
    return logicalOperation();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? illegal,
    TResult Function()? logicalOperation,
    TResult Function()? comparisonBitTest,
    TResult Function()? loadStore,
    TResult Function()? blockTransferSearch,
    TResult Function()? inputOutput,
    TResult Function()? branch,
    TResult Function()? jump,
    TResult Function()? lop,
    TResult Function()? call,
    TResult Function()? ret,
    required TResult orElse(),
  }) {
    if (logicalOperation != null) {
      return logicalOperation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Illegal value) illegal,
    required TResult Function(_LogicalOperation value) logicalOperation,
    required TResult Function(_ComparisonBitTest value) comparisonBitTest,
    required TResult Function(_LoadStore value) loadStore,
    required TResult Function(_BlockTransferSearch value) blockTransferSearch,
    required TResult Function(_InputOutput value) inputOutput,
    required TResult Function(_Branch value) branch,
    required TResult Function(_Jump value) jump,
    required TResult Function(_Lop value) lop,
    required TResult Function(_Call value) call,
    required TResult Function(_Return value) ret,
  }) {
    return logicalOperation(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Illegal value)? illegal,
    TResult Function(_LogicalOperation value)? logicalOperation,
    TResult Function(_ComparisonBitTest value)? comparisonBitTest,
    TResult Function(_LoadStore value)? loadStore,
    TResult Function(_BlockTransferSearch value)? blockTransferSearch,
    TResult Function(_InputOutput value)? inputOutput,
    TResult Function(_Branch value)? branch,
    TResult Function(_Jump value)? jump,
    TResult Function(_Lop value)? lop,
    TResult Function(_Call value)? call,
    TResult Function(_Return value)? ret,
    required TResult orElse(),
  }) {
    if (logicalOperation != null) {
      return logicalOperation(this);
    }
    return orElse();
  }
}

abstract class _LogicalOperation implements InstructionCategory {
  const factory _LogicalOperation() = _$_LogicalOperation;
}

/// @nodoc
abstract class _$ComparisonBitTestCopyWith<$Res> {
  factory _$ComparisonBitTestCopyWith(
          _ComparisonBitTest value, $Res Function(_ComparisonBitTest) then) =
      __$ComparisonBitTestCopyWithImpl<$Res>;
}

/// @nodoc
class __$ComparisonBitTestCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$ComparisonBitTestCopyWith<$Res> {
  __$ComparisonBitTestCopyWithImpl(
      _ComparisonBitTest _value, $Res Function(_ComparisonBitTest) _then)
      : super(_value, (v) => _then(v as _ComparisonBitTest));

  @override
  _ComparisonBitTest get _value => super._value as _ComparisonBitTest;
}

/// @nodoc

class _$_ComparisonBitTest implements _ComparisonBitTest {
  const _$_ComparisonBitTest();

  @override
  String toString() {
    return 'InstructionCategory.comparisonBitTest()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ComparisonBitTest);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() illegal,
    required TResult Function() logicalOperation,
    required TResult Function() comparisonBitTest,
    required TResult Function() loadStore,
    required TResult Function() blockTransferSearch,
    required TResult Function() inputOutput,
    required TResult Function() branch,
    required TResult Function() jump,
    required TResult Function() lop,
    required TResult Function() call,
    required TResult Function() ret,
  }) {
    return comparisonBitTest();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? illegal,
    TResult Function()? logicalOperation,
    TResult Function()? comparisonBitTest,
    TResult Function()? loadStore,
    TResult Function()? blockTransferSearch,
    TResult Function()? inputOutput,
    TResult Function()? branch,
    TResult Function()? jump,
    TResult Function()? lop,
    TResult Function()? call,
    TResult Function()? ret,
    required TResult orElse(),
  }) {
    if (comparisonBitTest != null) {
      return comparisonBitTest();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Illegal value) illegal,
    required TResult Function(_LogicalOperation value) logicalOperation,
    required TResult Function(_ComparisonBitTest value) comparisonBitTest,
    required TResult Function(_LoadStore value) loadStore,
    required TResult Function(_BlockTransferSearch value) blockTransferSearch,
    required TResult Function(_InputOutput value) inputOutput,
    required TResult Function(_Branch value) branch,
    required TResult Function(_Jump value) jump,
    required TResult Function(_Lop value) lop,
    required TResult Function(_Call value) call,
    required TResult Function(_Return value) ret,
  }) {
    return comparisonBitTest(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Illegal value)? illegal,
    TResult Function(_LogicalOperation value)? logicalOperation,
    TResult Function(_ComparisonBitTest value)? comparisonBitTest,
    TResult Function(_LoadStore value)? loadStore,
    TResult Function(_BlockTransferSearch value)? blockTransferSearch,
    TResult Function(_InputOutput value)? inputOutput,
    TResult Function(_Branch value)? branch,
    TResult Function(_Jump value)? jump,
    TResult Function(_Lop value)? lop,
    TResult Function(_Call value)? call,
    TResult Function(_Return value)? ret,
    required TResult orElse(),
  }) {
    if (comparisonBitTest != null) {
      return comparisonBitTest(this);
    }
    return orElse();
  }
}

abstract class _ComparisonBitTest implements InstructionCategory {
  const factory _ComparisonBitTest() = _$_ComparisonBitTest;
}

/// @nodoc
abstract class _$LoadStoreCopyWith<$Res> {
  factory _$LoadStoreCopyWith(
          _LoadStore value, $Res Function(_LoadStore) then) =
      __$LoadStoreCopyWithImpl<$Res>;
}

/// @nodoc
class __$LoadStoreCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$LoadStoreCopyWith<$Res> {
  __$LoadStoreCopyWithImpl(_LoadStore _value, $Res Function(_LoadStore) _then)
      : super(_value, (v) => _then(v as _LoadStore));

  @override
  _LoadStore get _value => super._value as _LoadStore;
}

/// @nodoc

class _$_LoadStore implements _LoadStore {
  const _$_LoadStore();

  @override
  String toString() {
    return 'InstructionCategory.loadStore()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LoadStore);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() illegal,
    required TResult Function() logicalOperation,
    required TResult Function() comparisonBitTest,
    required TResult Function() loadStore,
    required TResult Function() blockTransferSearch,
    required TResult Function() inputOutput,
    required TResult Function() branch,
    required TResult Function() jump,
    required TResult Function() lop,
    required TResult Function() call,
    required TResult Function() ret,
  }) {
    return loadStore();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? illegal,
    TResult Function()? logicalOperation,
    TResult Function()? comparisonBitTest,
    TResult Function()? loadStore,
    TResult Function()? blockTransferSearch,
    TResult Function()? inputOutput,
    TResult Function()? branch,
    TResult Function()? jump,
    TResult Function()? lop,
    TResult Function()? call,
    TResult Function()? ret,
    required TResult orElse(),
  }) {
    if (loadStore != null) {
      return loadStore();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Illegal value) illegal,
    required TResult Function(_LogicalOperation value) logicalOperation,
    required TResult Function(_ComparisonBitTest value) comparisonBitTest,
    required TResult Function(_LoadStore value) loadStore,
    required TResult Function(_BlockTransferSearch value) blockTransferSearch,
    required TResult Function(_InputOutput value) inputOutput,
    required TResult Function(_Branch value) branch,
    required TResult Function(_Jump value) jump,
    required TResult Function(_Lop value) lop,
    required TResult Function(_Call value) call,
    required TResult Function(_Return value) ret,
  }) {
    return loadStore(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Illegal value)? illegal,
    TResult Function(_LogicalOperation value)? logicalOperation,
    TResult Function(_ComparisonBitTest value)? comparisonBitTest,
    TResult Function(_LoadStore value)? loadStore,
    TResult Function(_BlockTransferSearch value)? blockTransferSearch,
    TResult Function(_InputOutput value)? inputOutput,
    TResult Function(_Branch value)? branch,
    TResult Function(_Jump value)? jump,
    TResult Function(_Lop value)? lop,
    TResult Function(_Call value)? call,
    TResult Function(_Return value)? ret,
    required TResult orElse(),
  }) {
    if (loadStore != null) {
      return loadStore(this);
    }
    return orElse();
  }
}

abstract class _LoadStore implements InstructionCategory {
  const factory _LoadStore() = _$_LoadStore;
}

/// @nodoc
abstract class _$BlockTransferSearchCopyWith<$Res> {
  factory _$BlockTransferSearchCopyWith(_BlockTransferSearch value,
          $Res Function(_BlockTransferSearch) then) =
      __$BlockTransferSearchCopyWithImpl<$Res>;
}

/// @nodoc
class __$BlockTransferSearchCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$BlockTransferSearchCopyWith<$Res> {
  __$BlockTransferSearchCopyWithImpl(
      _BlockTransferSearch _value, $Res Function(_BlockTransferSearch) _then)
      : super(_value, (v) => _then(v as _BlockTransferSearch));

  @override
  _BlockTransferSearch get _value => super._value as _BlockTransferSearch;
}

/// @nodoc

class _$_BlockTransferSearch implements _BlockTransferSearch {
  const _$_BlockTransferSearch();

  @override
  String toString() {
    return 'InstructionCategory.blockTransferSearch()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BlockTransferSearch);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() illegal,
    required TResult Function() logicalOperation,
    required TResult Function() comparisonBitTest,
    required TResult Function() loadStore,
    required TResult Function() blockTransferSearch,
    required TResult Function() inputOutput,
    required TResult Function() branch,
    required TResult Function() jump,
    required TResult Function() lop,
    required TResult Function() call,
    required TResult Function() ret,
  }) {
    return blockTransferSearch();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? illegal,
    TResult Function()? logicalOperation,
    TResult Function()? comparisonBitTest,
    TResult Function()? loadStore,
    TResult Function()? blockTransferSearch,
    TResult Function()? inputOutput,
    TResult Function()? branch,
    TResult Function()? jump,
    TResult Function()? lop,
    TResult Function()? call,
    TResult Function()? ret,
    required TResult orElse(),
  }) {
    if (blockTransferSearch != null) {
      return blockTransferSearch();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Illegal value) illegal,
    required TResult Function(_LogicalOperation value) logicalOperation,
    required TResult Function(_ComparisonBitTest value) comparisonBitTest,
    required TResult Function(_LoadStore value) loadStore,
    required TResult Function(_BlockTransferSearch value) blockTransferSearch,
    required TResult Function(_InputOutput value) inputOutput,
    required TResult Function(_Branch value) branch,
    required TResult Function(_Jump value) jump,
    required TResult Function(_Lop value) lop,
    required TResult Function(_Call value) call,
    required TResult Function(_Return value) ret,
  }) {
    return blockTransferSearch(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Illegal value)? illegal,
    TResult Function(_LogicalOperation value)? logicalOperation,
    TResult Function(_ComparisonBitTest value)? comparisonBitTest,
    TResult Function(_LoadStore value)? loadStore,
    TResult Function(_BlockTransferSearch value)? blockTransferSearch,
    TResult Function(_InputOutput value)? inputOutput,
    TResult Function(_Branch value)? branch,
    TResult Function(_Jump value)? jump,
    TResult Function(_Lop value)? lop,
    TResult Function(_Call value)? call,
    TResult Function(_Return value)? ret,
    required TResult orElse(),
  }) {
    if (blockTransferSearch != null) {
      return blockTransferSearch(this);
    }
    return orElse();
  }
}

abstract class _BlockTransferSearch implements InstructionCategory {
  const factory _BlockTransferSearch() = _$_BlockTransferSearch;
}

/// @nodoc
abstract class _$InputOutputCopyWith<$Res> {
  factory _$InputOutputCopyWith(
          _InputOutput value, $Res Function(_InputOutput) then) =
      __$InputOutputCopyWithImpl<$Res>;
}

/// @nodoc
class __$InputOutputCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$InputOutputCopyWith<$Res> {
  __$InputOutputCopyWithImpl(
      _InputOutput _value, $Res Function(_InputOutput) _then)
      : super(_value, (v) => _then(v as _InputOutput));

  @override
  _InputOutput get _value => super._value as _InputOutput;
}

/// @nodoc

class _$_InputOutput implements _InputOutput {
  const _$_InputOutput();

  @override
  String toString() {
    return 'InstructionCategory.inputOutput()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _InputOutput);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() illegal,
    required TResult Function() logicalOperation,
    required TResult Function() comparisonBitTest,
    required TResult Function() loadStore,
    required TResult Function() blockTransferSearch,
    required TResult Function() inputOutput,
    required TResult Function() branch,
    required TResult Function() jump,
    required TResult Function() lop,
    required TResult Function() call,
    required TResult Function() ret,
  }) {
    return inputOutput();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? illegal,
    TResult Function()? logicalOperation,
    TResult Function()? comparisonBitTest,
    TResult Function()? loadStore,
    TResult Function()? blockTransferSearch,
    TResult Function()? inputOutput,
    TResult Function()? branch,
    TResult Function()? jump,
    TResult Function()? lop,
    TResult Function()? call,
    TResult Function()? ret,
    required TResult orElse(),
  }) {
    if (inputOutput != null) {
      return inputOutput();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Illegal value) illegal,
    required TResult Function(_LogicalOperation value) logicalOperation,
    required TResult Function(_ComparisonBitTest value) comparisonBitTest,
    required TResult Function(_LoadStore value) loadStore,
    required TResult Function(_BlockTransferSearch value) blockTransferSearch,
    required TResult Function(_InputOutput value) inputOutput,
    required TResult Function(_Branch value) branch,
    required TResult Function(_Jump value) jump,
    required TResult Function(_Lop value) lop,
    required TResult Function(_Call value) call,
    required TResult Function(_Return value) ret,
  }) {
    return inputOutput(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Illegal value)? illegal,
    TResult Function(_LogicalOperation value)? logicalOperation,
    TResult Function(_ComparisonBitTest value)? comparisonBitTest,
    TResult Function(_LoadStore value)? loadStore,
    TResult Function(_BlockTransferSearch value)? blockTransferSearch,
    TResult Function(_InputOutput value)? inputOutput,
    TResult Function(_Branch value)? branch,
    TResult Function(_Jump value)? jump,
    TResult Function(_Lop value)? lop,
    TResult Function(_Call value)? call,
    TResult Function(_Return value)? ret,
    required TResult orElse(),
  }) {
    if (inputOutput != null) {
      return inputOutput(this);
    }
    return orElse();
  }
}

abstract class _InputOutput implements InstructionCategory {
  const factory _InputOutput() = _$_InputOutput;
}

/// @nodoc
abstract class _$BranchCopyWith<$Res> {
  factory _$BranchCopyWith(_Branch value, $Res Function(_Branch) then) =
      __$BranchCopyWithImpl<$Res>;
}

/// @nodoc
class __$BranchCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$BranchCopyWith<$Res> {
  __$BranchCopyWithImpl(_Branch _value, $Res Function(_Branch) _then)
      : super(_value, (v) => _then(v as _Branch));

  @override
  _Branch get _value => super._value as _Branch;
}

/// @nodoc

class _$_Branch implements _Branch {
  const _$_Branch();

  @override
  String toString() {
    return 'InstructionCategory.branch()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Branch);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() illegal,
    required TResult Function() logicalOperation,
    required TResult Function() comparisonBitTest,
    required TResult Function() loadStore,
    required TResult Function() blockTransferSearch,
    required TResult Function() inputOutput,
    required TResult Function() branch,
    required TResult Function() jump,
    required TResult Function() lop,
    required TResult Function() call,
    required TResult Function() ret,
  }) {
    return branch();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? illegal,
    TResult Function()? logicalOperation,
    TResult Function()? comparisonBitTest,
    TResult Function()? loadStore,
    TResult Function()? blockTransferSearch,
    TResult Function()? inputOutput,
    TResult Function()? branch,
    TResult Function()? jump,
    TResult Function()? lop,
    TResult Function()? call,
    TResult Function()? ret,
    required TResult orElse(),
  }) {
    if (branch != null) {
      return branch();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Illegal value) illegal,
    required TResult Function(_LogicalOperation value) logicalOperation,
    required TResult Function(_ComparisonBitTest value) comparisonBitTest,
    required TResult Function(_LoadStore value) loadStore,
    required TResult Function(_BlockTransferSearch value) blockTransferSearch,
    required TResult Function(_InputOutput value) inputOutput,
    required TResult Function(_Branch value) branch,
    required TResult Function(_Jump value) jump,
    required TResult Function(_Lop value) lop,
    required TResult Function(_Call value) call,
    required TResult Function(_Return value) ret,
  }) {
    return branch(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Illegal value)? illegal,
    TResult Function(_LogicalOperation value)? logicalOperation,
    TResult Function(_ComparisonBitTest value)? comparisonBitTest,
    TResult Function(_LoadStore value)? loadStore,
    TResult Function(_BlockTransferSearch value)? blockTransferSearch,
    TResult Function(_InputOutput value)? inputOutput,
    TResult Function(_Branch value)? branch,
    TResult Function(_Jump value)? jump,
    TResult Function(_Lop value)? lop,
    TResult Function(_Call value)? call,
    TResult Function(_Return value)? ret,
    required TResult orElse(),
  }) {
    if (branch != null) {
      return branch(this);
    }
    return orElse();
  }
}

abstract class _Branch implements InstructionCategory {
  const factory _Branch() = _$_Branch;
}

/// @nodoc
abstract class _$JumpCopyWith<$Res> {
  factory _$JumpCopyWith(_Jump value, $Res Function(_Jump) then) =
      __$JumpCopyWithImpl<$Res>;
}

/// @nodoc
class __$JumpCopyWithImpl<$Res> extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$JumpCopyWith<$Res> {
  __$JumpCopyWithImpl(_Jump _value, $Res Function(_Jump) _then)
      : super(_value, (v) => _then(v as _Jump));

  @override
  _Jump get _value => super._value as _Jump;
}

/// @nodoc

class _$_Jump implements _Jump {
  const _$_Jump();

  @override
  String toString() {
    return 'InstructionCategory.jump()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Jump);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() illegal,
    required TResult Function() logicalOperation,
    required TResult Function() comparisonBitTest,
    required TResult Function() loadStore,
    required TResult Function() blockTransferSearch,
    required TResult Function() inputOutput,
    required TResult Function() branch,
    required TResult Function() jump,
    required TResult Function() lop,
    required TResult Function() call,
    required TResult Function() ret,
  }) {
    return jump();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? illegal,
    TResult Function()? logicalOperation,
    TResult Function()? comparisonBitTest,
    TResult Function()? loadStore,
    TResult Function()? blockTransferSearch,
    TResult Function()? inputOutput,
    TResult Function()? branch,
    TResult Function()? jump,
    TResult Function()? lop,
    TResult Function()? call,
    TResult Function()? ret,
    required TResult orElse(),
  }) {
    if (jump != null) {
      return jump();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Illegal value) illegal,
    required TResult Function(_LogicalOperation value) logicalOperation,
    required TResult Function(_ComparisonBitTest value) comparisonBitTest,
    required TResult Function(_LoadStore value) loadStore,
    required TResult Function(_BlockTransferSearch value) blockTransferSearch,
    required TResult Function(_InputOutput value) inputOutput,
    required TResult Function(_Branch value) branch,
    required TResult Function(_Jump value) jump,
    required TResult Function(_Lop value) lop,
    required TResult Function(_Call value) call,
    required TResult Function(_Return value) ret,
  }) {
    return jump(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Illegal value)? illegal,
    TResult Function(_LogicalOperation value)? logicalOperation,
    TResult Function(_ComparisonBitTest value)? comparisonBitTest,
    TResult Function(_LoadStore value)? loadStore,
    TResult Function(_BlockTransferSearch value)? blockTransferSearch,
    TResult Function(_InputOutput value)? inputOutput,
    TResult Function(_Branch value)? branch,
    TResult Function(_Jump value)? jump,
    TResult Function(_Lop value)? lop,
    TResult Function(_Call value)? call,
    TResult Function(_Return value)? ret,
    required TResult orElse(),
  }) {
    if (jump != null) {
      return jump(this);
    }
    return orElse();
  }
}

abstract class _Jump implements InstructionCategory {
  const factory _Jump() = _$_Jump;
}

/// @nodoc
abstract class _$LopCopyWith<$Res> {
  factory _$LopCopyWith(_Lop value, $Res Function(_Lop) then) =
      __$LopCopyWithImpl<$Res>;
}

/// @nodoc
class __$LopCopyWithImpl<$Res> extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$LopCopyWith<$Res> {
  __$LopCopyWithImpl(_Lop _value, $Res Function(_Lop) _then)
      : super(_value, (v) => _then(v as _Lop));

  @override
  _Lop get _value => super._value as _Lop;
}

/// @nodoc

class _$_Lop implements _Lop {
  const _$_Lop();

  @override
  String toString() {
    return 'InstructionCategory.lop()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Lop);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() illegal,
    required TResult Function() logicalOperation,
    required TResult Function() comparisonBitTest,
    required TResult Function() loadStore,
    required TResult Function() blockTransferSearch,
    required TResult Function() inputOutput,
    required TResult Function() branch,
    required TResult Function() jump,
    required TResult Function() lop,
    required TResult Function() call,
    required TResult Function() ret,
  }) {
    return lop();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? illegal,
    TResult Function()? logicalOperation,
    TResult Function()? comparisonBitTest,
    TResult Function()? loadStore,
    TResult Function()? blockTransferSearch,
    TResult Function()? inputOutput,
    TResult Function()? branch,
    TResult Function()? jump,
    TResult Function()? lop,
    TResult Function()? call,
    TResult Function()? ret,
    required TResult orElse(),
  }) {
    if (lop != null) {
      return lop();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Illegal value) illegal,
    required TResult Function(_LogicalOperation value) logicalOperation,
    required TResult Function(_ComparisonBitTest value) comparisonBitTest,
    required TResult Function(_LoadStore value) loadStore,
    required TResult Function(_BlockTransferSearch value) blockTransferSearch,
    required TResult Function(_InputOutput value) inputOutput,
    required TResult Function(_Branch value) branch,
    required TResult Function(_Jump value) jump,
    required TResult Function(_Lop value) lop,
    required TResult Function(_Call value) call,
    required TResult Function(_Return value) ret,
  }) {
    return lop(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Illegal value)? illegal,
    TResult Function(_LogicalOperation value)? logicalOperation,
    TResult Function(_ComparisonBitTest value)? comparisonBitTest,
    TResult Function(_LoadStore value)? loadStore,
    TResult Function(_BlockTransferSearch value)? blockTransferSearch,
    TResult Function(_InputOutput value)? inputOutput,
    TResult Function(_Branch value)? branch,
    TResult Function(_Jump value)? jump,
    TResult Function(_Lop value)? lop,
    TResult Function(_Call value)? call,
    TResult Function(_Return value)? ret,
    required TResult orElse(),
  }) {
    if (lop != null) {
      return lop(this);
    }
    return orElse();
  }
}

abstract class _Lop implements InstructionCategory {
  const factory _Lop() = _$_Lop;
}

/// @nodoc
abstract class _$CallCopyWith<$Res> {
  factory _$CallCopyWith(_Call value, $Res Function(_Call) then) =
      __$CallCopyWithImpl<$Res>;
}

/// @nodoc
class __$CallCopyWithImpl<$Res> extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$CallCopyWith<$Res> {
  __$CallCopyWithImpl(_Call _value, $Res Function(_Call) _then)
      : super(_value, (v) => _then(v as _Call));

  @override
  _Call get _value => super._value as _Call;
}

/// @nodoc

class _$_Call implements _Call {
  const _$_Call();

  @override
  String toString() {
    return 'InstructionCategory.call()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Call);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() illegal,
    required TResult Function() logicalOperation,
    required TResult Function() comparisonBitTest,
    required TResult Function() loadStore,
    required TResult Function() blockTransferSearch,
    required TResult Function() inputOutput,
    required TResult Function() branch,
    required TResult Function() jump,
    required TResult Function() lop,
    required TResult Function() call,
    required TResult Function() ret,
  }) {
    return call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? illegal,
    TResult Function()? logicalOperation,
    TResult Function()? comparisonBitTest,
    TResult Function()? loadStore,
    TResult Function()? blockTransferSearch,
    TResult Function()? inputOutput,
    TResult Function()? branch,
    TResult Function()? jump,
    TResult Function()? lop,
    TResult Function()? call,
    TResult Function()? ret,
    required TResult orElse(),
  }) {
    if (call != null) {
      return call();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Illegal value) illegal,
    required TResult Function(_LogicalOperation value) logicalOperation,
    required TResult Function(_ComparisonBitTest value) comparisonBitTest,
    required TResult Function(_LoadStore value) loadStore,
    required TResult Function(_BlockTransferSearch value) blockTransferSearch,
    required TResult Function(_InputOutput value) inputOutput,
    required TResult Function(_Branch value) branch,
    required TResult Function(_Jump value) jump,
    required TResult Function(_Lop value) lop,
    required TResult Function(_Call value) call,
    required TResult Function(_Return value) ret,
  }) {
    return call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Illegal value)? illegal,
    TResult Function(_LogicalOperation value)? logicalOperation,
    TResult Function(_ComparisonBitTest value)? comparisonBitTest,
    TResult Function(_LoadStore value)? loadStore,
    TResult Function(_BlockTransferSearch value)? blockTransferSearch,
    TResult Function(_InputOutput value)? inputOutput,
    TResult Function(_Branch value)? branch,
    TResult Function(_Jump value)? jump,
    TResult Function(_Lop value)? lop,
    TResult Function(_Call value)? call,
    TResult Function(_Return value)? ret,
    required TResult orElse(),
  }) {
    if (call != null) {
      return call(this);
    }
    return orElse();
  }
}

abstract class _Call implements InstructionCategory {
  const factory _Call() = _$_Call;
}

/// @nodoc
abstract class _$ReturnCopyWith<$Res> {
  factory _$ReturnCopyWith(_Return value, $Res Function(_Return) then) =
      __$ReturnCopyWithImpl<$Res>;
}

/// @nodoc
class __$ReturnCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$ReturnCopyWith<$Res> {
  __$ReturnCopyWithImpl(_Return _value, $Res Function(_Return) _then)
      : super(_value, (v) => _then(v as _Return));

  @override
  _Return get _value => super._value as _Return;
}

/// @nodoc

class _$_Return implements _Return {
  const _$_Return();

  @override
  String toString() {
    return 'InstructionCategory.ret()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Return);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() illegal,
    required TResult Function() logicalOperation,
    required TResult Function() comparisonBitTest,
    required TResult Function() loadStore,
    required TResult Function() blockTransferSearch,
    required TResult Function() inputOutput,
    required TResult Function() branch,
    required TResult Function() jump,
    required TResult Function() lop,
    required TResult Function() call,
    required TResult Function() ret,
  }) {
    return ret();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? illegal,
    TResult Function()? logicalOperation,
    TResult Function()? comparisonBitTest,
    TResult Function()? loadStore,
    TResult Function()? blockTransferSearch,
    TResult Function()? inputOutput,
    TResult Function()? branch,
    TResult Function()? jump,
    TResult Function()? lop,
    TResult Function()? call,
    TResult Function()? ret,
    required TResult orElse(),
  }) {
    if (ret != null) {
      return ret();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Illegal value) illegal,
    required TResult Function(_LogicalOperation value) logicalOperation,
    required TResult Function(_ComparisonBitTest value) comparisonBitTest,
    required TResult Function(_LoadStore value) loadStore,
    required TResult Function(_BlockTransferSearch value) blockTransferSearch,
    required TResult Function(_InputOutput value) inputOutput,
    required TResult Function(_Branch value) branch,
    required TResult Function(_Jump value) jump,
    required TResult Function(_Lop value) lop,
    required TResult Function(_Call value) call,
    required TResult Function(_Return value) ret,
  }) {
    return ret(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Illegal value)? illegal,
    TResult Function(_LogicalOperation value)? logicalOperation,
    TResult Function(_ComparisonBitTest value)? comparisonBitTest,
    TResult Function(_LoadStore value)? loadStore,
    TResult Function(_BlockTransferSearch value)? blockTransferSearch,
    TResult Function(_InputOutput value)? inputOutput,
    TResult Function(_Branch value)? branch,
    TResult Function(_Jump value)? jump,
    TResult Function(_Lop value)? lop,
    TResult Function(_Call value)? call,
    TResult Function(_Return value)? ret,
    required TResult orElse(),
  }) {
    if (ret != null) {
      return ret(this);
    }
    return orElse();
  }
}

abstract class _Return implements InstructionCategory {
  const factory _Return() = _$_Return;
}

/// @nodoc
class _$OperandTearOff {
  const _$OperandTearOff();

  _None none() {
    return const _None();
  }

  _Reg reg(String registerName) {
    return _Reg(
      registerName,
    );
  }

  _Mem0Reg mem0Reg(String registerName) {
    return _Mem0Reg(
      registerName,
    );
  }

  _Mem0Imm16 mem0Imm16(int value) {
    return _Mem0Imm16(
      value,
    );
  }

  _Mem1Reg mem1Reg(String registerName) {
    return _Mem1Reg(
      registerName,
    );
  }

  _Mem1Imm16 mem1Imm16(int value) {
    return _Mem1Imm16(
      value,
    );
  }

  _Imm8 imm8(int value) {
    return _Imm8(
      value,
    );
  }

  _DispPlus dispPlus(int offset) {
    return _DispPlus(
      offset,
    );
  }

  _DispMinus dispMinus(int offset) {
    return _DispMinus(
      offset,
    );
  }

  _Mem0Cst8 mem0Cst8(int constant) {
    return _Mem0Cst8(
      constant,
    );
  }

  _Imm16 imm16(int value) {
    return _Imm16(
      value,
    );
  }
}

/// @nodoc
const $Operand = _$OperandTearOff();

/// @nodoc
mixin _$Operand {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(String registerName) reg,
    required TResult Function(String registerName) mem0Reg,
    required TResult Function(int value) mem0Imm16,
    required TResult Function(String registerName) mem1Reg,
    required TResult Function(int value) mem1Imm16,
    required TResult Function(int value) imm8,
    required TResult Function(int offset) dispPlus,
    required TResult Function(int offset) dispMinus,
    required TResult Function(int constant) mem0Cst8,
    required TResult Function(int value) imm16,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(String registerName)? reg,
    TResult Function(String registerName)? mem0Reg,
    TResult Function(int value)? mem0Imm16,
    TResult Function(String registerName)? mem1Reg,
    TResult Function(int value)? mem1Imm16,
    TResult Function(int value)? imm8,
    TResult Function(int offset)? dispPlus,
    TResult Function(int offset)? dispMinus,
    TResult Function(int constant)? mem0Cst8,
    TResult Function(int value)? imm16,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Reg value) reg,
    required TResult Function(_Mem0Reg value) mem0Reg,
    required TResult Function(_Mem0Imm16 value) mem0Imm16,
    required TResult Function(_Mem1Reg value) mem1Reg,
    required TResult Function(_Mem1Imm16 value) mem1Imm16,
    required TResult Function(_Imm8 value) imm8,
    required TResult Function(_DispPlus value) dispPlus,
    required TResult Function(_DispMinus value) dispMinus,
    required TResult Function(_Mem0Cst8 value) mem0Cst8,
    required TResult Function(_Imm16 value) imm16,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Reg value)? reg,
    TResult Function(_Mem0Reg value)? mem0Reg,
    TResult Function(_Mem0Imm16 value)? mem0Imm16,
    TResult Function(_Mem1Reg value)? mem1Reg,
    TResult Function(_Mem1Imm16 value)? mem1Imm16,
    TResult Function(_Imm8 value)? imm8,
    TResult Function(_DispPlus value)? dispPlus,
    TResult Function(_DispMinus value)? dispMinus,
    TResult Function(_Mem0Cst8 value)? mem0Cst8,
    TResult Function(_Imm16 value)? imm16,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OperandCopyWith<$Res> {
  factory $OperandCopyWith(Operand value, $Res Function(Operand) then) =
      _$OperandCopyWithImpl<$Res>;
}

/// @nodoc
class _$OperandCopyWithImpl<$Res> implements $OperandCopyWith<$Res> {
  _$OperandCopyWithImpl(this._value, this._then);

  final Operand _value;
  // ignore: unused_field
  final $Res Function(Operand) _then;
}

/// @nodoc
abstract class _$NoneCopyWith<$Res> {
  factory _$NoneCopyWith(_None value, $Res Function(_None) then) =
      __$NoneCopyWithImpl<$Res>;
}

/// @nodoc
class __$NoneCopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$NoneCopyWith<$Res> {
  __$NoneCopyWithImpl(_None _value, $Res Function(_None) _then)
      : super(_value, (v) => _then(v as _None));

  @override
  _None get _value => super._value as _None;
}

/// @nodoc

class _$_None extends _None {
  const _$_None() : super._();

  @override
  String toString() {
    return 'Operand.none()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _None);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(String registerName) reg,
    required TResult Function(String registerName) mem0Reg,
    required TResult Function(int value) mem0Imm16,
    required TResult Function(String registerName) mem1Reg,
    required TResult Function(int value) mem1Imm16,
    required TResult Function(int value) imm8,
    required TResult Function(int offset) dispPlus,
    required TResult Function(int offset) dispMinus,
    required TResult Function(int constant) mem0Cst8,
    required TResult Function(int value) imm16,
  }) {
    return none();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(String registerName)? reg,
    TResult Function(String registerName)? mem0Reg,
    TResult Function(int value)? mem0Imm16,
    TResult Function(String registerName)? mem1Reg,
    TResult Function(int value)? mem1Imm16,
    TResult Function(int value)? imm8,
    TResult Function(int offset)? dispPlus,
    TResult Function(int offset)? dispMinus,
    TResult Function(int constant)? mem0Cst8,
    TResult Function(int value)? imm16,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Reg value) reg,
    required TResult Function(_Mem0Reg value) mem0Reg,
    required TResult Function(_Mem0Imm16 value) mem0Imm16,
    required TResult Function(_Mem1Reg value) mem1Reg,
    required TResult Function(_Mem1Imm16 value) mem1Imm16,
    required TResult Function(_Imm8 value) imm8,
    required TResult Function(_DispPlus value) dispPlus,
    required TResult Function(_DispMinus value) dispMinus,
    required TResult Function(_Mem0Cst8 value) mem0Cst8,
    required TResult Function(_Imm16 value) imm16,
  }) {
    return none(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Reg value)? reg,
    TResult Function(_Mem0Reg value)? mem0Reg,
    TResult Function(_Mem0Imm16 value)? mem0Imm16,
    TResult Function(_Mem1Reg value)? mem1Reg,
    TResult Function(_Mem1Imm16 value)? mem1Imm16,
    TResult Function(_Imm8 value)? imm8,
    TResult Function(_DispPlus value)? dispPlus,
    TResult Function(_DispMinus value)? dispMinus,
    TResult Function(_Mem0Cst8 value)? mem0Cst8,
    TResult Function(_Imm16 value)? imm16,
    required TResult orElse(),
  }) {
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class _None extends Operand {
  const factory _None() = _$_None;
  const _None._() : super._();
}

/// @nodoc
abstract class _$RegCopyWith<$Res> {
  factory _$RegCopyWith(_Reg value, $Res Function(_Reg) then) =
      __$RegCopyWithImpl<$Res>;
  $Res call({String registerName});
}

/// @nodoc
class __$RegCopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$RegCopyWith<$Res> {
  __$RegCopyWithImpl(_Reg _value, $Res Function(_Reg) _then)
      : super(_value, (v) => _then(v as _Reg));

  @override
  _Reg get _value => super._value as _Reg;

  @override
  $Res call({
    Object? registerName = freezed,
  }) {
    return _then(_Reg(
      registerName == freezed
          ? _value.registerName
          : registerName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_Reg extends _Reg {
  const _$_Reg(this.registerName) : super._();

  @override
  final String registerName;

  @override
  String toString() {
    return 'Operand.reg(registerName: $registerName)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Reg &&
            (identical(other.registerName, registerName) ||
                const DeepCollectionEquality()
                    .equals(other.registerName, registerName)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(registerName);

  @JsonKey(ignore: true)
  @override
  _$RegCopyWith<_Reg> get copyWith =>
      __$RegCopyWithImpl<_Reg>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(String registerName) reg,
    required TResult Function(String registerName) mem0Reg,
    required TResult Function(int value) mem0Imm16,
    required TResult Function(String registerName) mem1Reg,
    required TResult Function(int value) mem1Imm16,
    required TResult Function(int value) imm8,
    required TResult Function(int offset) dispPlus,
    required TResult Function(int offset) dispMinus,
    required TResult Function(int constant) mem0Cst8,
    required TResult Function(int value) imm16,
  }) {
    return reg(registerName);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(String registerName)? reg,
    TResult Function(String registerName)? mem0Reg,
    TResult Function(int value)? mem0Imm16,
    TResult Function(String registerName)? mem1Reg,
    TResult Function(int value)? mem1Imm16,
    TResult Function(int value)? imm8,
    TResult Function(int offset)? dispPlus,
    TResult Function(int offset)? dispMinus,
    TResult Function(int constant)? mem0Cst8,
    TResult Function(int value)? imm16,
    required TResult orElse(),
  }) {
    if (reg != null) {
      return reg(registerName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Reg value) reg,
    required TResult Function(_Mem0Reg value) mem0Reg,
    required TResult Function(_Mem0Imm16 value) mem0Imm16,
    required TResult Function(_Mem1Reg value) mem1Reg,
    required TResult Function(_Mem1Imm16 value) mem1Imm16,
    required TResult Function(_Imm8 value) imm8,
    required TResult Function(_DispPlus value) dispPlus,
    required TResult Function(_DispMinus value) dispMinus,
    required TResult Function(_Mem0Cst8 value) mem0Cst8,
    required TResult Function(_Imm16 value) imm16,
  }) {
    return reg(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Reg value)? reg,
    TResult Function(_Mem0Reg value)? mem0Reg,
    TResult Function(_Mem0Imm16 value)? mem0Imm16,
    TResult Function(_Mem1Reg value)? mem1Reg,
    TResult Function(_Mem1Imm16 value)? mem1Imm16,
    TResult Function(_Imm8 value)? imm8,
    TResult Function(_DispPlus value)? dispPlus,
    TResult Function(_DispMinus value)? dispMinus,
    TResult Function(_Mem0Cst8 value)? mem0Cst8,
    TResult Function(_Imm16 value)? imm16,
    required TResult orElse(),
  }) {
    if (reg != null) {
      return reg(this);
    }
    return orElse();
  }
}

abstract class _Reg extends Operand {
  const factory _Reg(String registerName) = _$_Reg;
  const _Reg._() : super._();

  String get registerName => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$RegCopyWith<_Reg> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$Mem0RegCopyWith<$Res> {
  factory _$Mem0RegCopyWith(_Mem0Reg value, $Res Function(_Mem0Reg) then) =
      __$Mem0RegCopyWithImpl<$Res>;
  $Res call({String registerName});
}

/// @nodoc
class __$Mem0RegCopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$Mem0RegCopyWith<$Res> {
  __$Mem0RegCopyWithImpl(_Mem0Reg _value, $Res Function(_Mem0Reg) _then)
      : super(_value, (v) => _then(v as _Mem0Reg));

  @override
  _Mem0Reg get _value => super._value as _Mem0Reg;

  @override
  $Res call({
    Object? registerName = freezed,
  }) {
    return _then(_Mem0Reg(
      registerName == freezed
          ? _value.registerName
          : registerName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_Mem0Reg extends _Mem0Reg {
  const _$_Mem0Reg(this.registerName) : super._();

  @override
  final String registerName;

  @override
  String toString() {
    return 'Operand.mem0Reg(registerName: $registerName)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Mem0Reg &&
            (identical(other.registerName, registerName) ||
                const DeepCollectionEquality()
                    .equals(other.registerName, registerName)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(registerName);

  @JsonKey(ignore: true)
  @override
  _$Mem0RegCopyWith<_Mem0Reg> get copyWith =>
      __$Mem0RegCopyWithImpl<_Mem0Reg>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(String registerName) reg,
    required TResult Function(String registerName) mem0Reg,
    required TResult Function(int value) mem0Imm16,
    required TResult Function(String registerName) mem1Reg,
    required TResult Function(int value) mem1Imm16,
    required TResult Function(int value) imm8,
    required TResult Function(int offset) dispPlus,
    required TResult Function(int offset) dispMinus,
    required TResult Function(int constant) mem0Cst8,
    required TResult Function(int value) imm16,
  }) {
    return mem0Reg(registerName);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(String registerName)? reg,
    TResult Function(String registerName)? mem0Reg,
    TResult Function(int value)? mem0Imm16,
    TResult Function(String registerName)? mem1Reg,
    TResult Function(int value)? mem1Imm16,
    TResult Function(int value)? imm8,
    TResult Function(int offset)? dispPlus,
    TResult Function(int offset)? dispMinus,
    TResult Function(int constant)? mem0Cst8,
    TResult Function(int value)? imm16,
    required TResult orElse(),
  }) {
    if (mem0Reg != null) {
      return mem0Reg(registerName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Reg value) reg,
    required TResult Function(_Mem0Reg value) mem0Reg,
    required TResult Function(_Mem0Imm16 value) mem0Imm16,
    required TResult Function(_Mem1Reg value) mem1Reg,
    required TResult Function(_Mem1Imm16 value) mem1Imm16,
    required TResult Function(_Imm8 value) imm8,
    required TResult Function(_DispPlus value) dispPlus,
    required TResult Function(_DispMinus value) dispMinus,
    required TResult Function(_Mem0Cst8 value) mem0Cst8,
    required TResult Function(_Imm16 value) imm16,
  }) {
    return mem0Reg(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Reg value)? reg,
    TResult Function(_Mem0Reg value)? mem0Reg,
    TResult Function(_Mem0Imm16 value)? mem0Imm16,
    TResult Function(_Mem1Reg value)? mem1Reg,
    TResult Function(_Mem1Imm16 value)? mem1Imm16,
    TResult Function(_Imm8 value)? imm8,
    TResult Function(_DispPlus value)? dispPlus,
    TResult Function(_DispMinus value)? dispMinus,
    TResult Function(_Mem0Cst8 value)? mem0Cst8,
    TResult Function(_Imm16 value)? imm16,
    required TResult orElse(),
  }) {
    if (mem0Reg != null) {
      return mem0Reg(this);
    }
    return orElse();
  }
}

abstract class _Mem0Reg extends Operand {
  const factory _Mem0Reg(String registerName) = _$_Mem0Reg;
  const _Mem0Reg._() : super._();

  String get registerName => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$Mem0RegCopyWith<_Mem0Reg> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$Mem0Imm16CopyWith<$Res> {
  factory _$Mem0Imm16CopyWith(
          _Mem0Imm16 value, $Res Function(_Mem0Imm16) then) =
      __$Mem0Imm16CopyWithImpl<$Res>;
  $Res call({int value});
}

/// @nodoc
class __$Mem0Imm16CopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$Mem0Imm16CopyWith<$Res> {
  __$Mem0Imm16CopyWithImpl(_Mem0Imm16 _value, $Res Function(_Mem0Imm16) _then)
      : super(_value, (v) => _then(v as _Mem0Imm16));

  @override
  _Mem0Imm16 get _value => super._value as _Mem0Imm16;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_Mem0Imm16(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_Mem0Imm16 extends _Mem0Imm16 {
  const _$_Mem0Imm16(this.value) : super._();

  @override
  final int value;

  @override
  String toString() {
    return 'Operand.mem0Imm16(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Mem0Imm16 &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(value);

  @JsonKey(ignore: true)
  @override
  _$Mem0Imm16CopyWith<_Mem0Imm16> get copyWith =>
      __$Mem0Imm16CopyWithImpl<_Mem0Imm16>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(String registerName) reg,
    required TResult Function(String registerName) mem0Reg,
    required TResult Function(int value) mem0Imm16,
    required TResult Function(String registerName) mem1Reg,
    required TResult Function(int value) mem1Imm16,
    required TResult Function(int value) imm8,
    required TResult Function(int offset) dispPlus,
    required TResult Function(int offset) dispMinus,
    required TResult Function(int constant) mem0Cst8,
    required TResult Function(int value) imm16,
  }) {
    return mem0Imm16(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(String registerName)? reg,
    TResult Function(String registerName)? mem0Reg,
    TResult Function(int value)? mem0Imm16,
    TResult Function(String registerName)? mem1Reg,
    TResult Function(int value)? mem1Imm16,
    TResult Function(int value)? imm8,
    TResult Function(int offset)? dispPlus,
    TResult Function(int offset)? dispMinus,
    TResult Function(int constant)? mem0Cst8,
    TResult Function(int value)? imm16,
    required TResult orElse(),
  }) {
    if (mem0Imm16 != null) {
      return mem0Imm16(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Reg value) reg,
    required TResult Function(_Mem0Reg value) mem0Reg,
    required TResult Function(_Mem0Imm16 value) mem0Imm16,
    required TResult Function(_Mem1Reg value) mem1Reg,
    required TResult Function(_Mem1Imm16 value) mem1Imm16,
    required TResult Function(_Imm8 value) imm8,
    required TResult Function(_DispPlus value) dispPlus,
    required TResult Function(_DispMinus value) dispMinus,
    required TResult Function(_Mem0Cst8 value) mem0Cst8,
    required TResult Function(_Imm16 value) imm16,
  }) {
    return mem0Imm16(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Reg value)? reg,
    TResult Function(_Mem0Reg value)? mem0Reg,
    TResult Function(_Mem0Imm16 value)? mem0Imm16,
    TResult Function(_Mem1Reg value)? mem1Reg,
    TResult Function(_Mem1Imm16 value)? mem1Imm16,
    TResult Function(_Imm8 value)? imm8,
    TResult Function(_DispPlus value)? dispPlus,
    TResult Function(_DispMinus value)? dispMinus,
    TResult Function(_Mem0Cst8 value)? mem0Cst8,
    TResult Function(_Imm16 value)? imm16,
    required TResult orElse(),
  }) {
    if (mem0Imm16 != null) {
      return mem0Imm16(this);
    }
    return orElse();
  }
}

abstract class _Mem0Imm16 extends Operand {
  const factory _Mem0Imm16(int value) = _$_Mem0Imm16;
  const _Mem0Imm16._() : super._();

  int get value => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$Mem0Imm16CopyWith<_Mem0Imm16> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$Mem1RegCopyWith<$Res> {
  factory _$Mem1RegCopyWith(_Mem1Reg value, $Res Function(_Mem1Reg) then) =
      __$Mem1RegCopyWithImpl<$Res>;
  $Res call({String registerName});
}

/// @nodoc
class __$Mem1RegCopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$Mem1RegCopyWith<$Res> {
  __$Mem1RegCopyWithImpl(_Mem1Reg _value, $Res Function(_Mem1Reg) _then)
      : super(_value, (v) => _then(v as _Mem1Reg));

  @override
  _Mem1Reg get _value => super._value as _Mem1Reg;

  @override
  $Res call({
    Object? registerName = freezed,
  }) {
    return _then(_Mem1Reg(
      registerName == freezed
          ? _value.registerName
          : registerName // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$_Mem1Reg extends _Mem1Reg {
  const _$_Mem1Reg(this.registerName) : super._();

  @override
  final String registerName;

  @override
  String toString() {
    return 'Operand.mem1Reg(registerName: $registerName)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Mem1Reg &&
            (identical(other.registerName, registerName) ||
                const DeepCollectionEquality()
                    .equals(other.registerName, registerName)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(registerName);

  @JsonKey(ignore: true)
  @override
  _$Mem1RegCopyWith<_Mem1Reg> get copyWith =>
      __$Mem1RegCopyWithImpl<_Mem1Reg>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(String registerName) reg,
    required TResult Function(String registerName) mem0Reg,
    required TResult Function(int value) mem0Imm16,
    required TResult Function(String registerName) mem1Reg,
    required TResult Function(int value) mem1Imm16,
    required TResult Function(int value) imm8,
    required TResult Function(int offset) dispPlus,
    required TResult Function(int offset) dispMinus,
    required TResult Function(int constant) mem0Cst8,
    required TResult Function(int value) imm16,
  }) {
    return mem1Reg(registerName);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(String registerName)? reg,
    TResult Function(String registerName)? mem0Reg,
    TResult Function(int value)? mem0Imm16,
    TResult Function(String registerName)? mem1Reg,
    TResult Function(int value)? mem1Imm16,
    TResult Function(int value)? imm8,
    TResult Function(int offset)? dispPlus,
    TResult Function(int offset)? dispMinus,
    TResult Function(int constant)? mem0Cst8,
    TResult Function(int value)? imm16,
    required TResult orElse(),
  }) {
    if (mem1Reg != null) {
      return mem1Reg(registerName);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Reg value) reg,
    required TResult Function(_Mem0Reg value) mem0Reg,
    required TResult Function(_Mem0Imm16 value) mem0Imm16,
    required TResult Function(_Mem1Reg value) mem1Reg,
    required TResult Function(_Mem1Imm16 value) mem1Imm16,
    required TResult Function(_Imm8 value) imm8,
    required TResult Function(_DispPlus value) dispPlus,
    required TResult Function(_DispMinus value) dispMinus,
    required TResult Function(_Mem0Cst8 value) mem0Cst8,
    required TResult Function(_Imm16 value) imm16,
  }) {
    return mem1Reg(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Reg value)? reg,
    TResult Function(_Mem0Reg value)? mem0Reg,
    TResult Function(_Mem0Imm16 value)? mem0Imm16,
    TResult Function(_Mem1Reg value)? mem1Reg,
    TResult Function(_Mem1Imm16 value)? mem1Imm16,
    TResult Function(_Imm8 value)? imm8,
    TResult Function(_DispPlus value)? dispPlus,
    TResult Function(_DispMinus value)? dispMinus,
    TResult Function(_Mem0Cst8 value)? mem0Cst8,
    TResult Function(_Imm16 value)? imm16,
    required TResult orElse(),
  }) {
    if (mem1Reg != null) {
      return mem1Reg(this);
    }
    return orElse();
  }
}

abstract class _Mem1Reg extends Operand {
  const factory _Mem1Reg(String registerName) = _$_Mem1Reg;
  const _Mem1Reg._() : super._();

  String get registerName => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$Mem1RegCopyWith<_Mem1Reg> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$Mem1Imm16CopyWith<$Res> {
  factory _$Mem1Imm16CopyWith(
          _Mem1Imm16 value, $Res Function(_Mem1Imm16) then) =
      __$Mem1Imm16CopyWithImpl<$Res>;
  $Res call({int value});
}

/// @nodoc
class __$Mem1Imm16CopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$Mem1Imm16CopyWith<$Res> {
  __$Mem1Imm16CopyWithImpl(_Mem1Imm16 _value, $Res Function(_Mem1Imm16) _then)
      : super(_value, (v) => _then(v as _Mem1Imm16));

  @override
  _Mem1Imm16 get _value => super._value as _Mem1Imm16;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_Mem1Imm16(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_Mem1Imm16 extends _Mem1Imm16 {
  const _$_Mem1Imm16(this.value) : super._();

  @override
  final int value;

  @override
  String toString() {
    return 'Operand.mem1Imm16(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Mem1Imm16 &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(value);

  @JsonKey(ignore: true)
  @override
  _$Mem1Imm16CopyWith<_Mem1Imm16> get copyWith =>
      __$Mem1Imm16CopyWithImpl<_Mem1Imm16>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(String registerName) reg,
    required TResult Function(String registerName) mem0Reg,
    required TResult Function(int value) mem0Imm16,
    required TResult Function(String registerName) mem1Reg,
    required TResult Function(int value) mem1Imm16,
    required TResult Function(int value) imm8,
    required TResult Function(int offset) dispPlus,
    required TResult Function(int offset) dispMinus,
    required TResult Function(int constant) mem0Cst8,
    required TResult Function(int value) imm16,
  }) {
    return mem1Imm16(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(String registerName)? reg,
    TResult Function(String registerName)? mem0Reg,
    TResult Function(int value)? mem0Imm16,
    TResult Function(String registerName)? mem1Reg,
    TResult Function(int value)? mem1Imm16,
    TResult Function(int value)? imm8,
    TResult Function(int offset)? dispPlus,
    TResult Function(int offset)? dispMinus,
    TResult Function(int constant)? mem0Cst8,
    TResult Function(int value)? imm16,
    required TResult orElse(),
  }) {
    if (mem1Imm16 != null) {
      return mem1Imm16(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Reg value) reg,
    required TResult Function(_Mem0Reg value) mem0Reg,
    required TResult Function(_Mem0Imm16 value) mem0Imm16,
    required TResult Function(_Mem1Reg value) mem1Reg,
    required TResult Function(_Mem1Imm16 value) mem1Imm16,
    required TResult Function(_Imm8 value) imm8,
    required TResult Function(_DispPlus value) dispPlus,
    required TResult Function(_DispMinus value) dispMinus,
    required TResult Function(_Mem0Cst8 value) mem0Cst8,
    required TResult Function(_Imm16 value) imm16,
  }) {
    return mem1Imm16(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Reg value)? reg,
    TResult Function(_Mem0Reg value)? mem0Reg,
    TResult Function(_Mem0Imm16 value)? mem0Imm16,
    TResult Function(_Mem1Reg value)? mem1Reg,
    TResult Function(_Mem1Imm16 value)? mem1Imm16,
    TResult Function(_Imm8 value)? imm8,
    TResult Function(_DispPlus value)? dispPlus,
    TResult Function(_DispMinus value)? dispMinus,
    TResult Function(_Mem0Cst8 value)? mem0Cst8,
    TResult Function(_Imm16 value)? imm16,
    required TResult orElse(),
  }) {
    if (mem1Imm16 != null) {
      return mem1Imm16(this);
    }
    return orElse();
  }
}

abstract class _Mem1Imm16 extends Operand {
  const factory _Mem1Imm16(int value) = _$_Mem1Imm16;
  const _Mem1Imm16._() : super._();

  int get value => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$Mem1Imm16CopyWith<_Mem1Imm16> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$Imm8CopyWith<$Res> {
  factory _$Imm8CopyWith(_Imm8 value, $Res Function(_Imm8) then) =
      __$Imm8CopyWithImpl<$Res>;
  $Res call({int value});
}

/// @nodoc
class __$Imm8CopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$Imm8CopyWith<$Res> {
  __$Imm8CopyWithImpl(_Imm8 _value, $Res Function(_Imm8) _then)
      : super(_value, (v) => _then(v as _Imm8));

  @override
  _Imm8 get _value => super._value as _Imm8;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_Imm8(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_Imm8 extends _Imm8 {
  const _$_Imm8(this.value) : super._();

  @override
  final int value;

  @override
  String toString() {
    return 'Operand.imm8(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Imm8 &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(value);

  @JsonKey(ignore: true)
  @override
  _$Imm8CopyWith<_Imm8> get copyWith =>
      __$Imm8CopyWithImpl<_Imm8>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(String registerName) reg,
    required TResult Function(String registerName) mem0Reg,
    required TResult Function(int value) mem0Imm16,
    required TResult Function(String registerName) mem1Reg,
    required TResult Function(int value) mem1Imm16,
    required TResult Function(int value) imm8,
    required TResult Function(int offset) dispPlus,
    required TResult Function(int offset) dispMinus,
    required TResult Function(int constant) mem0Cst8,
    required TResult Function(int value) imm16,
  }) {
    return imm8(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(String registerName)? reg,
    TResult Function(String registerName)? mem0Reg,
    TResult Function(int value)? mem0Imm16,
    TResult Function(String registerName)? mem1Reg,
    TResult Function(int value)? mem1Imm16,
    TResult Function(int value)? imm8,
    TResult Function(int offset)? dispPlus,
    TResult Function(int offset)? dispMinus,
    TResult Function(int constant)? mem0Cst8,
    TResult Function(int value)? imm16,
    required TResult orElse(),
  }) {
    if (imm8 != null) {
      return imm8(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Reg value) reg,
    required TResult Function(_Mem0Reg value) mem0Reg,
    required TResult Function(_Mem0Imm16 value) mem0Imm16,
    required TResult Function(_Mem1Reg value) mem1Reg,
    required TResult Function(_Mem1Imm16 value) mem1Imm16,
    required TResult Function(_Imm8 value) imm8,
    required TResult Function(_DispPlus value) dispPlus,
    required TResult Function(_DispMinus value) dispMinus,
    required TResult Function(_Mem0Cst8 value) mem0Cst8,
    required TResult Function(_Imm16 value) imm16,
  }) {
    return imm8(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Reg value)? reg,
    TResult Function(_Mem0Reg value)? mem0Reg,
    TResult Function(_Mem0Imm16 value)? mem0Imm16,
    TResult Function(_Mem1Reg value)? mem1Reg,
    TResult Function(_Mem1Imm16 value)? mem1Imm16,
    TResult Function(_Imm8 value)? imm8,
    TResult Function(_DispPlus value)? dispPlus,
    TResult Function(_DispMinus value)? dispMinus,
    TResult Function(_Mem0Cst8 value)? mem0Cst8,
    TResult Function(_Imm16 value)? imm16,
    required TResult orElse(),
  }) {
    if (imm8 != null) {
      return imm8(this);
    }
    return orElse();
  }
}

abstract class _Imm8 extends Operand {
  const factory _Imm8(int value) = _$_Imm8;
  const _Imm8._() : super._();

  int get value => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$Imm8CopyWith<_Imm8> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$DispPlusCopyWith<$Res> {
  factory _$DispPlusCopyWith(_DispPlus value, $Res Function(_DispPlus) then) =
      __$DispPlusCopyWithImpl<$Res>;
  $Res call({int offset});
}

/// @nodoc
class __$DispPlusCopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$DispPlusCopyWith<$Res> {
  __$DispPlusCopyWithImpl(_DispPlus _value, $Res Function(_DispPlus) _then)
      : super(_value, (v) => _then(v as _DispPlus));

  @override
  _DispPlus get _value => super._value as _DispPlus;

  @override
  $Res call({
    Object? offset = freezed,
  }) {
    return _then(_DispPlus(
      offset == freezed
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_DispPlus extends _DispPlus {
  const _$_DispPlus(this.offset) : super._();

  @override
  final int offset;

  @override
  String toString() {
    return 'Operand.dispPlus(offset: $offset)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DispPlus &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(offset);

  @JsonKey(ignore: true)
  @override
  _$DispPlusCopyWith<_DispPlus> get copyWith =>
      __$DispPlusCopyWithImpl<_DispPlus>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(String registerName) reg,
    required TResult Function(String registerName) mem0Reg,
    required TResult Function(int value) mem0Imm16,
    required TResult Function(String registerName) mem1Reg,
    required TResult Function(int value) mem1Imm16,
    required TResult Function(int value) imm8,
    required TResult Function(int offset) dispPlus,
    required TResult Function(int offset) dispMinus,
    required TResult Function(int constant) mem0Cst8,
    required TResult Function(int value) imm16,
  }) {
    return dispPlus(offset);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(String registerName)? reg,
    TResult Function(String registerName)? mem0Reg,
    TResult Function(int value)? mem0Imm16,
    TResult Function(String registerName)? mem1Reg,
    TResult Function(int value)? mem1Imm16,
    TResult Function(int value)? imm8,
    TResult Function(int offset)? dispPlus,
    TResult Function(int offset)? dispMinus,
    TResult Function(int constant)? mem0Cst8,
    TResult Function(int value)? imm16,
    required TResult orElse(),
  }) {
    if (dispPlus != null) {
      return dispPlus(offset);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Reg value) reg,
    required TResult Function(_Mem0Reg value) mem0Reg,
    required TResult Function(_Mem0Imm16 value) mem0Imm16,
    required TResult Function(_Mem1Reg value) mem1Reg,
    required TResult Function(_Mem1Imm16 value) mem1Imm16,
    required TResult Function(_Imm8 value) imm8,
    required TResult Function(_DispPlus value) dispPlus,
    required TResult Function(_DispMinus value) dispMinus,
    required TResult Function(_Mem0Cst8 value) mem0Cst8,
    required TResult Function(_Imm16 value) imm16,
  }) {
    return dispPlus(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Reg value)? reg,
    TResult Function(_Mem0Reg value)? mem0Reg,
    TResult Function(_Mem0Imm16 value)? mem0Imm16,
    TResult Function(_Mem1Reg value)? mem1Reg,
    TResult Function(_Mem1Imm16 value)? mem1Imm16,
    TResult Function(_Imm8 value)? imm8,
    TResult Function(_DispPlus value)? dispPlus,
    TResult Function(_DispMinus value)? dispMinus,
    TResult Function(_Mem0Cst8 value)? mem0Cst8,
    TResult Function(_Imm16 value)? imm16,
    required TResult orElse(),
  }) {
    if (dispPlus != null) {
      return dispPlus(this);
    }
    return orElse();
  }
}

abstract class _DispPlus extends Operand {
  const factory _DispPlus(int offset) = _$_DispPlus;
  const _DispPlus._() : super._();

  int get offset => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$DispPlusCopyWith<_DispPlus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$DispMinusCopyWith<$Res> {
  factory _$DispMinusCopyWith(
          _DispMinus value, $Res Function(_DispMinus) then) =
      __$DispMinusCopyWithImpl<$Res>;
  $Res call({int offset});
}

/// @nodoc
class __$DispMinusCopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$DispMinusCopyWith<$Res> {
  __$DispMinusCopyWithImpl(_DispMinus _value, $Res Function(_DispMinus) _then)
      : super(_value, (v) => _then(v as _DispMinus));

  @override
  _DispMinus get _value => super._value as _DispMinus;

  @override
  $Res call({
    Object? offset = freezed,
  }) {
    return _then(_DispMinus(
      offset == freezed
          ? _value.offset
          : offset // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_DispMinus extends _DispMinus {
  const _$_DispMinus(this.offset) : super._();

  @override
  final int offset;

  @override
  String toString() {
    return 'Operand.dispMinus(offset: $offset)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _DispMinus &&
            (identical(other.offset, offset) ||
                const DeepCollectionEquality().equals(other.offset, offset)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(offset);

  @JsonKey(ignore: true)
  @override
  _$DispMinusCopyWith<_DispMinus> get copyWith =>
      __$DispMinusCopyWithImpl<_DispMinus>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(String registerName) reg,
    required TResult Function(String registerName) mem0Reg,
    required TResult Function(int value) mem0Imm16,
    required TResult Function(String registerName) mem1Reg,
    required TResult Function(int value) mem1Imm16,
    required TResult Function(int value) imm8,
    required TResult Function(int offset) dispPlus,
    required TResult Function(int offset) dispMinus,
    required TResult Function(int constant) mem0Cst8,
    required TResult Function(int value) imm16,
  }) {
    return dispMinus(offset);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(String registerName)? reg,
    TResult Function(String registerName)? mem0Reg,
    TResult Function(int value)? mem0Imm16,
    TResult Function(String registerName)? mem1Reg,
    TResult Function(int value)? mem1Imm16,
    TResult Function(int value)? imm8,
    TResult Function(int offset)? dispPlus,
    TResult Function(int offset)? dispMinus,
    TResult Function(int constant)? mem0Cst8,
    TResult Function(int value)? imm16,
    required TResult orElse(),
  }) {
    if (dispMinus != null) {
      return dispMinus(offset);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Reg value) reg,
    required TResult Function(_Mem0Reg value) mem0Reg,
    required TResult Function(_Mem0Imm16 value) mem0Imm16,
    required TResult Function(_Mem1Reg value) mem1Reg,
    required TResult Function(_Mem1Imm16 value) mem1Imm16,
    required TResult Function(_Imm8 value) imm8,
    required TResult Function(_DispPlus value) dispPlus,
    required TResult Function(_DispMinus value) dispMinus,
    required TResult Function(_Mem0Cst8 value) mem0Cst8,
    required TResult Function(_Imm16 value) imm16,
  }) {
    return dispMinus(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Reg value)? reg,
    TResult Function(_Mem0Reg value)? mem0Reg,
    TResult Function(_Mem0Imm16 value)? mem0Imm16,
    TResult Function(_Mem1Reg value)? mem1Reg,
    TResult Function(_Mem1Imm16 value)? mem1Imm16,
    TResult Function(_Imm8 value)? imm8,
    TResult Function(_DispPlus value)? dispPlus,
    TResult Function(_DispMinus value)? dispMinus,
    TResult Function(_Mem0Cst8 value)? mem0Cst8,
    TResult Function(_Imm16 value)? imm16,
    required TResult orElse(),
  }) {
    if (dispMinus != null) {
      return dispMinus(this);
    }
    return orElse();
  }
}

abstract class _DispMinus extends Operand {
  const factory _DispMinus(int offset) = _$_DispMinus;
  const _DispMinus._() : super._();

  int get offset => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$DispMinusCopyWith<_DispMinus> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$Mem0Cst8CopyWith<$Res> {
  factory _$Mem0Cst8CopyWith(_Mem0Cst8 value, $Res Function(_Mem0Cst8) then) =
      __$Mem0Cst8CopyWithImpl<$Res>;
  $Res call({int constant});
}

/// @nodoc
class __$Mem0Cst8CopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$Mem0Cst8CopyWith<$Res> {
  __$Mem0Cst8CopyWithImpl(_Mem0Cst8 _value, $Res Function(_Mem0Cst8) _then)
      : super(_value, (v) => _then(v as _Mem0Cst8));

  @override
  _Mem0Cst8 get _value => super._value as _Mem0Cst8;

  @override
  $Res call({
    Object? constant = freezed,
  }) {
    return _then(_Mem0Cst8(
      constant == freezed
          ? _value.constant
          : constant // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_Mem0Cst8 extends _Mem0Cst8 {
  const _$_Mem0Cst8(this.constant) : super._();

  @override
  final int constant;

  @override
  String toString() {
    return 'Operand.mem0Cst8(constant: $constant)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Mem0Cst8 &&
            (identical(other.constant, constant) ||
                const DeepCollectionEquality()
                    .equals(other.constant, constant)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(constant);

  @JsonKey(ignore: true)
  @override
  _$Mem0Cst8CopyWith<_Mem0Cst8> get copyWith =>
      __$Mem0Cst8CopyWithImpl<_Mem0Cst8>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(String registerName) reg,
    required TResult Function(String registerName) mem0Reg,
    required TResult Function(int value) mem0Imm16,
    required TResult Function(String registerName) mem1Reg,
    required TResult Function(int value) mem1Imm16,
    required TResult Function(int value) imm8,
    required TResult Function(int offset) dispPlus,
    required TResult Function(int offset) dispMinus,
    required TResult Function(int constant) mem0Cst8,
    required TResult Function(int value) imm16,
  }) {
    return mem0Cst8(constant);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(String registerName)? reg,
    TResult Function(String registerName)? mem0Reg,
    TResult Function(int value)? mem0Imm16,
    TResult Function(String registerName)? mem1Reg,
    TResult Function(int value)? mem1Imm16,
    TResult Function(int value)? imm8,
    TResult Function(int offset)? dispPlus,
    TResult Function(int offset)? dispMinus,
    TResult Function(int constant)? mem0Cst8,
    TResult Function(int value)? imm16,
    required TResult orElse(),
  }) {
    if (mem0Cst8 != null) {
      return mem0Cst8(constant);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Reg value) reg,
    required TResult Function(_Mem0Reg value) mem0Reg,
    required TResult Function(_Mem0Imm16 value) mem0Imm16,
    required TResult Function(_Mem1Reg value) mem1Reg,
    required TResult Function(_Mem1Imm16 value) mem1Imm16,
    required TResult Function(_Imm8 value) imm8,
    required TResult Function(_DispPlus value) dispPlus,
    required TResult Function(_DispMinus value) dispMinus,
    required TResult Function(_Mem0Cst8 value) mem0Cst8,
    required TResult Function(_Imm16 value) imm16,
  }) {
    return mem0Cst8(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Reg value)? reg,
    TResult Function(_Mem0Reg value)? mem0Reg,
    TResult Function(_Mem0Imm16 value)? mem0Imm16,
    TResult Function(_Mem1Reg value)? mem1Reg,
    TResult Function(_Mem1Imm16 value)? mem1Imm16,
    TResult Function(_Imm8 value)? imm8,
    TResult Function(_DispPlus value)? dispPlus,
    TResult Function(_DispMinus value)? dispMinus,
    TResult Function(_Mem0Cst8 value)? mem0Cst8,
    TResult Function(_Imm16 value)? imm16,
    required TResult orElse(),
  }) {
    if (mem0Cst8 != null) {
      return mem0Cst8(this);
    }
    return orElse();
  }
}

abstract class _Mem0Cst8 extends Operand {
  const factory _Mem0Cst8(int constant) = _$_Mem0Cst8;
  const _Mem0Cst8._() : super._();

  int get constant => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$Mem0Cst8CopyWith<_Mem0Cst8> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$Imm16CopyWith<$Res> {
  factory _$Imm16CopyWith(_Imm16 value, $Res Function(_Imm16) then) =
      __$Imm16CopyWithImpl<$Res>;
  $Res call({int value});
}

/// @nodoc
class __$Imm16CopyWithImpl<$Res> extends _$OperandCopyWithImpl<$Res>
    implements _$Imm16CopyWith<$Res> {
  __$Imm16CopyWithImpl(_Imm16 _value, $Res Function(_Imm16) _then)
      : super(_value, (v) => _then(v as _Imm16));

  @override
  _Imm16 get _value => super._value as _Imm16;

  @override
  $Res call({
    Object? value = freezed,
  }) {
    return _then(_Imm16(
      value == freezed
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$_Imm16 extends _Imm16 {
  const _$_Imm16(this.value) : super._();

  @override
  final int value;

  @override
  String toString() {
    return 'Operand.imm16(value: $value)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _Imm16 &&
            (identical(other.value, value) ||
                const DeepCollectionEquality().equals(other.value, value)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(value);

  @JsonKey(ignore: true)
  @override
  _$Imm16CopyWith<_Imm16> get copyWith =>
      __$Imm16CopyWithImpl<_Imm16>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() none,
    required TResult Function(String registerName) reg,
    required TResult Function(String registerName) mem0Reg,
    required TResult Function(int value) mem0Imm16,
    required TResult Function(String registerName) mem1Reg,
    required TResult Function(int value) mem1Imm16,
    required TResult Function(int value) imm8,
    required TResult Function(int offset) dispPlus,
    required TResult Function(int offset) dispMinus,
    required TResult Function(int constant) mem0Cst8,
    required TResult Function(int value) imm16,
  }) {
    return imm16(value);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? none,
    TResult Function(String registerName)? reg,
    TResult Function(String registerName)? mem0Reg,
    TResult Function(int value)? mem0Imm16,
    TResult Function(String registerName)? mem1Reg,
    TResult Function(int value)? mem1Imm16,
    TResult Function(int value)? imm8,
    TResult Function(int offset)? dispPlus,
    TResult Function(int offset)? dispMinus,
    TResult Function(int constant)? mem0Cst8,
    TResult Function(int value)? imm16,
    required TResult orElse(),
  }) {
    if (imm16 != null) {
      return imm16(value);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_None value) none,
    required TResult Function(_Reg value) reg,
    required TResult Function(_Mem0Reg value) mem0Reg,
    required TResult Function(_Mem0Imm16 value) mem0Imm16,
    required TResult Function(_Mem1Reg value) mem1Reg,
    required TResult Function(_Mem1Imm16 value) mem1Imm16,
    required TResult Function(_Imm8 value) imm8,
    required TResult Function(_DispPlus value) dispPlus,
    required TResult Function(_DispMinus value) dispMinus,
    required TResult Function(_Mem0Cst8 value) mem0Cst8,
    required TResult Function(_Imm16 value) imm16,
  }) {
    return imm16(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_None value)? none,
    TResult Function(_Reg value)? reg,
    TResult Function(_Mem0Reg value)? mem0Reg,
    TResult Function(_Mem0Imm16 value)? mem0Imm16,
    TResult Function(_Mem1Reg value)? mem1Reg,
    TResult Function(_Mem1Imm16 value)? mem1Imm16,
    TResult Function(_Imm8 value)? imm8,
    TResult Function(_DispPlus value)? dispPlus,
    TResult Function(_DispMinus value)? dispMinus,
    TResult Function(_Mem0Cst8 value)? mem0Cst8,
    TResult Function(_Imm16 value)? imm16,
    required TResult orElse(),
  }) {
    if (imm16 != null) {
      return imm16(this);
    }
    return orElse();
  }
}

abstract class _Imm16 extends Operand {
  const factory _Imm16(int value) = _$_Imm16;
  const _Imm16._() : super._();

  int get value => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  _$Imm16CopyWith<_Imm16> get copyWith => throw _privateConstructorUsedError;
}
