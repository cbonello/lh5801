// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides

part of 'operand_dump.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$RadixTearOff {
  const _$RadixTearOff();

  _Binary binary() {
    return const _Binary();
  }

  _Decimal decimal() {
    return const _Decimal();
  }

  _Hexadecimal hexadecimal() {
    return const _Hexadecimal();
  }
}

/// @nodoc
const $Radix = _$RadixTearOff();

/// @nodoc
mixin _$Radix {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() binary,
    required TResult Function() decimal,
    required TResult Function() hexadecimal,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? binary,
    TResult Function()? decimal,
    TResult Function()? hexadecimal,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Binary value) binary,
    required TResult Function(_Decimal value) decimal,
    required TResult Function(_Hexadecimal value) hexadecimal,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Binary value)? binary,
    TResult Function(_Decimal value)? decimal,
    TResult Function(_Hexadecimal value)? hexadecimal,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RadixCopyWith<$Res> {
  factory $RadixCopyWith(Radix value, $Res Function(Radix) then) =
      _$RadixCopyWithImpl<$Res>;
}

/// @nodoc
class _$RadixCopyWithImpl<$Res> implements $RadixCopyWith<$Res> {
  _$RadixCopyWithImpl(this._value, this._then);

  final Radix _value;
  // ignore: unused_field
  final $Res Function(Radix) _then;
}

/// @nodoc
abstract class _$BinaryCopyWith<$Res> {
  factory _$BinaryCopyWith(_Binary value, $Res Function(_Binary) then) =
      __$BinaryCopyWithImpl<$Res>;
}

/// @nodoc
class __$BinaryCopyWithImpl<$Res> extends _$RadixCopyWithImpl<$Res>
    implements _$BinaryCopyWith<$Res> {
  __$BinaryCopyWithImpl(_Binary _value, $Res Function(_Binary) _then)
      : super(_value, (v) => _then(v as _Binary));

  @override
  _Binary get _value => super._value as _Binary;
}

/// @nodoc

class _$_Binary implements _Binary {
  const _$_Binary();

  @override
  String toString() {
    return 'Radix.binary()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Binary);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() binary,
    required TResult Function() decimal,
    required TResult Function() hexadecimal,
  }) {
    return binary();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? binary,
    TResult Function()? decimal,
    TResult Function()? hexadecimal,
    required TResult orElse(),
  }) {
    if (binary != null) {
      return binary();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Binary value) binary,
    required TResult Function(_Decimal value) decimal,
    required TResult Function(_Hexadecimal value) hexadecimal,
  }) {
    return binary(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Binary value)? binary,
    TResult Function(_Decimal value)? decimal,
    TResult Function(_Hexadecimal value)? hexadecimal,
    required TResult orElse(),
  }) {
    if (binary != null) {
      return binary(this);
    }
    return orElse();
  }
}

abstract class _Binary implements Radix {
  const factory _Binary() = _$_Binary;
}

/// @nodoc
abstract class _$DecimalCopyWith<$Res> {
  factory _$DecimalCopyWith(_Decimal value, $Res Function(_Decimal) then) =
      __$DecimalCopyWithImpl<$Res>;
}

/// @nodoc
class __$DecimalCopyWithImpl<$Res> extends _$RadixCopyWithImpl<$Res>
    implements _$DecimalCopyWith<$Res> {
  __$DecimalCopyWithImpl(_Decimal _value, $Res Function(_Decimal) _then)
      : super(_value, (v) => _then(v as _Decimal));

  @override
  _Decimal get _value => super._value as _Decimal;
}

/// @nodoc

class _$_Decimal implements _Decimal {
  const _$_Decimal();

  @override
  String toString() {
    return 'Radix.decimal()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Decimal);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() binary,
    required TResult Function() decimal,
    required TResult Function() hexadecimal,
  }) {
    return decimal();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? binary,
    TResult Function()? decimal,
    TResult Function()? hexadecimal,
    required TResult orElse(),
  }) {
    if (decimal != null) {
      return decimal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Binary value) binary,
    required TResult Function(_Decimal value) decimal,
    required TResult Function(_Hexadecimal value) hexadecimal,
  }) {
    return decimal(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Binary value)? binary,
    TResult Function(_Decimal value)? decimal,
    TResult Function(_Hexadecimal value)? hexadecimal,
    required TResult orElse(),
  }) {
    if (decimal != null) {
      return decimal(this);
    }
    return orElse();
  }
}

abstract class _Decimal implements Radix {
  const factory _Decimal() = _$_Decimal;
}

/// @nodoc
abstract class _$HexadecimalCopyWith<$Res> {
  factory _$HexadecimalCopyWith(
          _Hexadecimal value, $Res Function(_Hexadecimal) then) =
      __$HexadecimalCopyWithImpl<$Res>;
}

/// @nodoc
class __$HexadecimalCopyWithImpl<$Res> extends _$RadixCopyWithImpl<$Res>
    implements _$HexadecimalCopyWith<$Res> {
  __$HexadecimalCopyWithImpl(
      _Hexadecimal _value, $Res Function(_Hexadecimal) _then)
      : super(_value, (v) => _then(v as _Hexadecimal));

  @override
  _Hexadecimal get _value => super._value as _Hexadecimal;
}

/// @nodoc

class _$_Hexadecimal implements _Hexadecimal {
  const _$_Hexadecimal();

  @override
  String toString() {
    return 'Radix.hexadecimal()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Hexadecimal);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() binary,
    required TResult Function() decimal,
    required TResult Function() hexadecimal,
  }) {
    return hexadecimal();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? binary,
    TResult Function()? decimal,
    TResult Function()? hexadecimal,
    required TResult orElse(),
  }) {
    if (hexadecimal != null) {
      return hexadecimal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Binary value) binary,
    required TResult Function(_Decimal value) decimal,
    required TResult Function(_Hexadecimal value) hexadecimal,
  }) {
    return hexadecimal(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Binary value)? binary,
    TResult Function(_Decimal value)? decimal,
    TResult Function(_Hexadecimal value)? hexadecimal,
    required TResult orElse(),
  }) {
    if (hexadecimal != null) {
      return hexadecimal(this);
    }
    return orElse();
  }
}

abstract class _Hexadecimal implements Radix {
  const factory _Hexadecimal() = _$_Hexadecimal;
}
