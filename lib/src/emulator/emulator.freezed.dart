// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'emulator.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$PinTypeTearOff {
  const _$PinTypeTearOff();

// ignore: unused_element
  _Reset reset() {
    return const _Reset();
  }

// ignore: unused_element
  _NMI nmi() {
    return const _NMI();
  }

// ignore: unused_element
  _MI mi() {
    return const _MI();
  }

// ignore: unused_element
  _PU pu() {
    return const _PU();
  }

// ignore: unused_element
  _PV pv() {
    return const _PV();
  }

// ignore: unused_element
  _BF bf() {
    return const _BF();
  }

// ignore: unused_element
  _Disp disp() {
    return const _Disp();
  }
}

// ignore: unused_element
const $PinType = _$PinTypeTearOff();

mixin _$PinType {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result reset(),
    @required Result nmi(),
    @required Result mi(),
    @required Result pu(),
    @required Result pv(),
    @required Result bf(),
    @required Result disp(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result reset(),
    Result nmi(),
    Result mi(),
    Result pu(),
    Result pv(),
    Result bf(),
    Result disp(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result reset(_Reset value),
    @required Result nmi(_NMI value),
    @required Result mi(_MI value),
    @required Result pu(_PU value),
    @required Result pv(_PV value),
    @required Result bf(_BF value),
    @required Result disp(_Disp value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result reset(_Reset value),
    Result nmi(_NMI value),
    Result mi(_MI value),
    Result pu(_PU value),
    Result pv(_PV value),
    Result bf(_BF value),
    Result disp(_Disp value),
    @required Result orElse(),
  });
}

abstract class $PinTypeCopyWith<$Res> {
  factory $PinTypeCopyWith(PinType value, $Res Function(PinType) then) =
      _$PinTypeCopyWithImpl<$Res>;
}

class _$PinTypeCopyWithImpl<$Res> implements $PinTypeCopyWith<$Res> {
  _$PinTypeCopyWithImpl(this._value, this._then);

  final PinType _value;
  // ignore: unused_field
  final $Res Function(PinType) _then;
}

abstract class _$ResetCopyWith<$Res> {
  factory _$ResetCopyWith(_Reset value, $Res Function(_Reset) then) =
      __$ResetCopyWithImpl<$Res>;
}

class __$ResetCopyWithImpl<$Res> extends _$PinTypeCopyWithImpl<$Res>
    implements _$ResetCopyWith<$Res> {
  __$ResetCopyWithImpl(_Reset _value, $Res Function(_Reset) _then)
      : super(_value, (v) => _then(v as _Reset));

  @override
  _Reset get _value => super._value as _Reset;
}

class _$_Reset implements _Reset {
  const _$_Reset();

  @override
  String toString() {
    return 'PinType.reset()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Reset);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result reset(),
    @required Result nmi(),
    @required Result mi(),
    @required Result pu(),
    @required Result pv(),
    @required Result bf(),
    @required Result disp(),
  }) {
    assert(reset != null);
    assert(nmi != null);
    assert(mi != null);
    assert(pu != null);
    assert(pv != null);
    assert(bf != null);
    assert(disp != null);
    return reset();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result reset(),
    Result nmi(),
    Result mi(),
    Result pu(),
    Result pv(),
    Result bf(),
    Result disp(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (reset != null) {
      return reset();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result reset(_Reset value),
    @required Result nmi(_NMI value),
    @required Result mi(_MI value),
    @required Result pu(_PU value),
    @required Result pv(_PV value),
    @required Result bf(_BF value),
    @required Result disp(_Disp value),
  }) {
    assert(reset != null);
    assert(nmi != null);
    assert(mi != null);
    assert(pu != null);
    assert(pv != null);
    assert(bf != null);
    assert(disp != null);
    return reset(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result reset(_Reset value),
    Result nmi(_NMI value),
    Result mi(_MI value),
    Result pu(_PU value),
    Result pv(_PV value),
    Result bf(_BF value),
    Result disp(_Disp value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (reset != null) {
      return reset(this);
    }
    return orElse();
  }
}

abstract class _Reset implements PinType {
  const factory _Reset() = _$_Reset;
}

abstract class _$NMICopyWith<$Res> {
  factory _$NMICopyWith(_NMI value, $Res Function(_NMI) then) =
      __$NMICopyWithImpl<$Res>;
}

class __$NMICopyWithImpl<$Res> extends _$PinTypeCopyWithImpl<$Res>
    implements _$NMICopyWith<$Res> {
  __$NMICopyWithImpl(_NMI _value, $Res Function(_NMI) _then)
      : super(_value, (v) => _then(v as _NMI));

  @override
  _NMI get _value => super._value as _NMI;
}

class _$_NMI implements _NMI {
  const _$_NMI();

  @override
  String toString() {
    return 'PinType.nmi()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _NMI);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result reset(),
    @required Result nmi(),
    @required Result mi(),
    @required Result pu(),
    @required Result pv(),
    @required Result bf(),
    @required Result disp(),
  }) {
    assert(reset != null);
    assert(nmi != null);
    assert(mi != null);
    assert(pu != null);
    assert(pv != null);
    assert(bf != null);
    assert(disp != null);
    return nmi();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result reset(),
    Result nmi(),
    Result mi(),
    Result pu(),
    Result pv(),
    Result bf(),
    Result disp(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (nmi != null) {
      return nmi();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result reset(_Reset value),
    @required Result nmi(_NMI value),
    @required Result mi(_MI value),
    @required Result pu(_PU value),
    @required Result pv(_PV value),
    @required Result bf(_BF value),
    @required Result disp(_Disp value),
  }) {
    assert(reset != null);
    assert(nmi != null);
    assert(mi != null);
    assert(pu != null);
    assert(pv != null);
    assert(bf != null);
    assert(disp != null);
    return nmi(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result reset(_Reset value),
    Result nmi(_NMI value),
    Result mi(_MI value),
    Result pu(_PU value),
    Result pv(_PV value),
    Result bf(_BF value),
    Result disp(_Disp value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (nmi != null) {
      return nmi(this);
    }
    return orElse();
  }
}

abstract class _NMI implements PinType {
  const factory _NMI() = _$_NMI;
}

abstract class _$MICopyWith<$Res> {
  factory _$MICopyWith(_MI value, $Res Function(_MI) then) =
      __$MICopyWithImpl<$Res>;
}

class __$MICopyWithImpl<$Res> extends _$PinTypeCopyWithImpl<$Res>
    implements _$MICopyWith<$Res> {
  __$MICopyWithImpl(_MI _value, $Res Function(_MI) _then)
      : super(_value, (v) => _then(v as _MI));

  @override
  _MI get _value => super._value as _MI;
}

class _$_MI implements _MI {
  const _$_MI();

  @override
  String toString() {
    return 'PinType.mi()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _MI);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result reset(),
    @required Result nmi(),
    @required Result mi(),
    @required Result pu(),
    @required Result pv(),
    @required Result bf(),
    @required Result disp(),
  }) {
    assert(reset != null);
    assert(nmi != null);
    assert(mi != null);
    assert(pu != null);
    assert(pv != null);
    assert(bf != null);
    assert(disp != null);
    return mi();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result reset(),
    Result nmi(),
    Result mi(),
    Result pu(),
    Result pv(),
    Result bf(),
    Result disp(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mi != null) {
      return mi();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result reset(_Reset value),
    @required Result nmi(_NMI value),
    @required Result mi(_MI value),
    @required Result pu(_PU value),
    @required Result pv(_PV value),
    @required Result bf(_BF value),
    @required Result disp(_Disp value),
  }) {
    assert(reset != null);
    assert(nmi != null);
    assert(mi != null);
    assert(pu != null);
    assert(pv != null);
    assert(bf != null);
    assert(disp != null);
    return mi(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result reset(_Reset value),
    Result nmi(_NMI value),
    Result mi(_MI value),
    Result pu(_PU value),
    Result pv(_PV value),
    Result bf(_BF value),
    Result disp(_Disp value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mi != null) {
      return mi(this);
    }
    return orElse();
  }
}

abstract class _MI implements PinType {
  const factory _MI() = _$_MI;
}

abstract class _$PUCopyWith<$Res> {
  factory _$PUCopyWith(_PU value, $Res Function(_PU) then) =
      __$PUCopyWithImpl<$Res>;
}

class __$PUCopyWithImpl<$Res> extends _$PinTypeCopyWithImpl<$Res>
    implements _$PUCopyWith<$Res> {
  __$PUCopyWithImpl(_PU _value, $Res Function(_PU) _then)
      : super(_value, (v) => _then(v as _PU));

  @override
  _PU get _value => super._value as _PU;
}

class _$_PU implements _PU {
  const _$_PU();

  @override
  String toString() {
    return 'PinType.pu()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PU);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result reset(),
    @required Result nmi(),
    @required Result mi(),
    @required Result pu(),
    @required Result pv(),
    @required Result bf(),
    @required Result disp(),
  }) {
    assert(reset != null);
    assert(nmi != null);
    assert(mi != null);
    assert(pu != null);
    assert(pv != null);
    assert(bf != null);
    assert(disp != null);
    return pu();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result reset(),
    Result nmi(),
    Result mi(),
    Result pu(),
    Result pv(),
    Result bf(),
    Result disp(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (pu != null) {
      return pu();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result reset(_Reset value),
    @required Result nmi(_NMI value),
    @required Result mi(_MI value),
    @required Result pu(_PU value),
    @required Result pv(_PV value),
    @required Result bf(_BF value),
    @required Result disp(_Disp value),
  }) {
    assert(reset != null);
    assert(nmi != null);
    assert(mi != null);
    assert(pu != null);
    assert(pv != null);
    assert(bf != null);
    assert(disp != null);
    return pu(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result reset(_Reset value),
    Result nmi(_NMI value),
    Result mi(_MI value),
    Result pu(_PU value),
    Result pv(_PV value),
    Result bf(_BF value),
    Result disp(_Disp value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (pu != null) {
      return pu(this);
    }
    return orElse();
  }
}

abstract class _PU implements PinType {
  const factory _PU() = _$_PU;
}

abstract class _$PVCopyWith<$Res> {
  factory _$PVCopyWith(_PV value, $Res Function(_PV) then) =
      __$PVCopyWithImpl<$Res>;
}

class __$PVCopyWithImpl<$Res> extends _$PinTypeCopyWithImpl<$Res>
    implements _$PVCopyWith<$Res> {
  __$PVCopyWithImpl(_PV _value, $Res Function(_PV) _then)
      : super(_value, (v) => _then(v as _PV));

  @override
  _PV get _value => super._value as _PV;
}

class _$_PV implements _PV {
  const _$_PV();

  @override
  String toString() {
    return 'PinType.pv()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _PV);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result reset(),
    @required Result nmi(),
    @required Result mi(),
    @required Result pu(),
    @required Result pv(),
    @required Result bf(),
    @required Result disp(),
  }) {
    assert(reset != null);
    assert(nmi != null);
    assert(mi != null);
    assert(pu != null);
    assert(pv != null);
    assert(bf != null);
    assert(disp != null);
    return pv();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result reset(),
    Result nmi(),
    Result mi(),
    Result pu(),
    Result pv(),
    Result bf(),
    Result disp(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (pv != null) {
      return pv();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result reset(_Reset value),
    @required Result nmi(_NMI value),
    @required Result mi(_MI value),
    @required Result pu(_PU value),
    @required Result pv(_PV value),
    @required Result bf(_BF value),
    @required Result disp(_Disp value),
  }) {
    assert(reset != null);
    assert(nmi != null);
    assert(mi != null);
    assert(pu != null);
    assert(pv != null);
    assert(bf != null);
    assert(disp != null);
    return pv(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result reset(_Reset value),
    Result nmi(_NMI value),
    Result mi(_MI value),
    Result pu(_PU value),
    Result pv(_PV value),
    Result bf(_BF value),
    Result disp(_Disp value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (pv != null) {
      return pv(this);
    }
    return orElse();
  }
}

abstract class _PV implements PinType {
  const factory _PV() = _$_PV;
}

abstract class _$BFCopyWith<$Res> {
  factory _$BFCopyWith(_BF value, $Res Function(_BF) then) =
      __$BFCopyWithImpl<$Res>;
}

class __$BFCopyWithImpl<$Res> extends _$PinTypeCopyWithImpl<$Res>
    implements _$BFCopyWith<$Res> {
  __$BFCopyWithImpl(_BF _value, $Res Function(_BF) _then)
      : super(_value, (v) => _then(v as _BF));

  @override
  _BF get _value => super._value as _BF;
}

class _$_BF implements _BF {
  const _$_BF();

  @override
  String toString() {
    return 'PinType.bf()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BF);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result reset(),
    @required Result nmi(),
    @required Result mi(),
    @required Result pu(),
    @required Result pv(),
    @required Result bf(),
    @required Result disp(),
  }) {
    assert(reset != null);
    assert(nmi != null);
    assert(mi != null);
    assert(pu != null);
    assert(pv != null);
    assert(bf != null);
    assert(disp != null);
    return bf();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result reset(),
    Result nmi(),
    Result mi(),
    Result pu(),
    Result pv(),
    Result bf(),
    Result disp(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (bf != null) {
      return bf();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result reset(_Reset value),
    @required Result nmi(_NMI value),
    @required Result mi(_MI value),
    @required Result pu(_PU value),
    @required Result pv(_PV value),
    @required Result bf(_BF value),
    @required Result disp(_Disp value),
  }) {
    assert(reset != null);
    assert(nmi != null);
    assert(mi != null);
    assert(pu != null);
    assert(pv != null);
    assert(bf != null);
    assert(disp != null);
    return bf(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result reset(_Reset value),
    Result nmi(_NMI value),
    Result mi(_MI value),
    Result pu(_PU value),
    Result pv(_PV value),
    Result bf(_BF value),
    Result disp(_Disp value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (bf != null) {
      return bf(this);
    }
    return orElse();
  }
}

abstract class _BF implements PinType {
  const factory _BF() = _$_BF;
}

abstract class _$DispCopyWith<$Res> {
  factory _$DispCopyWith(_Disp value, $Res Function(_Disp) then) =
      __$DispCopyWithImpl<$Res>;
}

class __$DispCopyWithImpl<$Res> extends _$PinTypeCopyWithImpl<$Res>
    implements _$DispCopyWith<$Res> {
  __$DispCopyWithImpl(_Disp _value, $Res Function(_Disp) _then)
      : super(_value, (v) => _then(v as _Disp));

  @override
  _Disp get _value => super._value as _Disp;
}

class _$_Disp implements _Disp {
  const _$_Disp();

  @override
  String toString() {
    return 'PinType.disp()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Disp);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result reset(),
    @required Result nmi(),
    @required Result mi(),
    @required Result pu(),
    @required Result pv(),
    @required Result bf(),
    @required Result disp(),
  }) {
    assert(reset != null);
    assert(nmi != null);
    assert(mi != null);
    assert(pu != null);
    assert(pv != null);
    assert(bf != null);
    assert(disp != null);
    return disp();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result reset(),
    Result nmi(),
    Result mi(),
    Result pu(),
    Result pv(),
    Result bf(),
    Result disp(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (disp != null) {
      return disp();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result reset(_Reset value),
    @required Result nmi(_NMI value),
    @required Result mi(_MI value),
    @required Result pu(_PU value),
    @required Result pv(_PV value),
    @required Result bf(_BF value),
    @required Result disp(_Disp value),
  }) {
    assert(reset != null);
    assert(nmi != null);
    assert(mi != null);
    assert(pu != null);
    assert(pv != null);
    assert(bf != null);
    assert(disp != null);
    return disp(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result reset(_Reset value),
    Result nmi(_NMI value),
    Result mi(_MI value),
    Result pu(_PU value),
    Result pv(_PV value),
    Result bf(_BF value),
    Result disp(_Disp value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (disp != null) {
      return disp(this);
    }
    return orElse();
  }
}

abstract class _Disp implements PinType {
  const factory _Disp() = _$_Disp;
}

class _$InterruptTypeTearOff {
  const _$InterruptTypeTearOff();

// ignore: unused_element
  _IR0 ir0() {
    return const _IR0();
  }

// ignore: unused_element
  _IR1 ir1() {
    return const _IR1();
  }

// ignore: unused_element
  _IR2 ir2() {
    return const _IR2();
  }
}

// ignore: unused_element
const $InterruptType = _$InterruptTypeTearOff();

mixin _$InterruptType {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result ir0(),
    @required Result ir1(),
    @required Result ir2(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result ir0(),
    Result ir1(),
    Result ir2(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result ir0(_IR0 value),
    @required Result ir1(_IR1 value),
    @required Result ir2(_IR2 value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result ir0(_IR0 value),
    Result ir1(_IR1 value),
    Result ir2(_IR2 value),
    @required Result orElse(),
  });
}

abstract class $InterruptTypeCopyWith<$Res> {
  factory $InterruptTypeCopyWith(
          InterruptType value, $Res Function(InterruptType) then) =
      _$InterruptTypeCopyWithImpl<$Res>;
}

class _$InterruptTypeCopyWithImpl<$Res>
    implements $InterruptTypeCopyWith<$Res> {
  _$InterruptTypeCopyWithImpl(this._value, this._then);

  final InterruptType _value;
  // ignore: unused_field
  final $Res Function(InterruptType) _then;
}

abstract class _$IR0CopyWith<$Res> {
  factory _$IR0CopyWith(_IR0 value, $Res Function(_IR0) then) =
      __$IR0CopyWithImpl<$Res>;
}

class __$IR0CopyWithImpl<$Res> extends _$InterruptTypeCopyWithImpl<$Res>
    implements _$IR0CopyWith<$Res> {
  __$IR0CopyWithImpl(_IR0 _value, $Res Function(_IR0) _then)
      : super(_value, (v) => _then(v as _IR0));

  @override
  _IR0 get _value => super._value as _IR0;
}

class _$_IR0 implements _IR0 {
  const _$_IR0();

  @override
  String toString() {
    return 'InterruptType.ir0()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _IR0);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result ir0(),
    @required Result ir1(),
    @required Result ir2(),
  }) {
    assert(ir0 != null);
    assert(ir1 != null);
    assert(ir2 != null);
    return ir0();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result ir0(),
    Result ir1(),
    Result ir2(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ir0 != null) {
      return ir0();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result ir0(_IR0 value),
    @required Result ir1(_IR1 value),
    @required Result ir2(_IR2 value),
  }) {
    assert(ir0 != null);
    assert(ir1 != null);
    assert(ir2 != null);
    return ir0(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result ir0(_IR0 value),
    Result ir1(_IR1 value),
    Result ir2(_IR2 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ir0 != null) {
      return ir0(this);
    }
    return orElse();
  }
}

abstract class _IR0 implements InterruptType {
  const factory _IR0() = _$_IR0;
}

abstract class _$IR1CopyWith<$Res> {
  factory _$IR1CopyWith(_IR1 value, $Res Function(_IR1) then) =
      __$IR1CopyWithImpl<$Res>;
}

class __$IR1CopyWithImpl<$Res> extends _$InterruptTypeCopyWithImpl<$Res>
    implements _$IR1CopyWith<$Res> {
  __$IR1CopyWithImpl(_IR1 _value, $Res Function(_IR1) _then)
      : super(_value, (v) => _then(v as _IR1));

  @override
  _IR1 get _value => super._value as _IR1;
}

class _$_IR1 implements _IR1 {
  const _$_IR1();

  @override
  String toString() {
    return 'InterruptType.ir1()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _IR1);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result ir0(),
    @required Result ir1(),
    @required Result ir2(),
  }) {
    assert(ir0 != null);
    assert(ir1 != null);
    assert(ir2 != null);
    return ir1();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result ir0(),
    Result ir1(),
    Result ir2(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ir1 != null) {
      return ir1();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result ir0(_IR0 value),
    @required Result ir1(_IR1 value),
    @required Result ir2(_IR2 value),
  }) {
    assert(ir0 != null);
    assert(ir1 != null);
    assert(ir2 != null);
    return ir1(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result ir0(_IR0 value),
    Result ir1(_IR1 value),
    Result ir2(_IR2 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ir1 != null) {
      return ir1(this);
    }
    return orElse();
  }
}

abstract class _IR1 implements InterruptType {
  const factory _IR1() = _$_IR1;
}

abstract class _$IR2CopyWith<$Res> {
  factory _$IR2CopyWith(_IR2 value, $Res Function(_IR2) then) =
      __$IR2CopyWithImpl<$Res>;
}

class __$IR2CopyWithImpl<$Res> extends _$InterruptTypeCopyWithImpl<$Res>
    implements _$IR2CopyWith<$Res> {
  __$IR2CopyWithImpl(_IR2 _value, $Res Function(_IR2) _then)
      : super(_value, (v) => _then(v as _IR2));

  @override
  _IR2 get _value => super._value as _IR2;
}

class _$_IR2 implements _IR2 {
  const _$_IR2();

  @override
  String toString() {
    return 'InterruptType.ir2()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _IR2);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result ir0(),
    @required Result ir1(),
    @required Result ir2(),
  }) {
    assert(ir0 != null);
    assert(ir1 != null);
    assert(ir2 != null);
    return ir2();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result ir0(),
    Result ir1(),
    Result ir2(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ir2 != null) {
      return ir2();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result ir0(_IR0 value),
    @required Result ir1(_IR1 value),
    @required Result ir2(_IR2 value),
  }) {
    assert(ir0 != null);
    assert(ir1 != null);
    assert(ir2 != null);
    return ir2(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result ir0(_IR0 value),
    Result ir1(_IR1 value),
    Result ir2(_IR2 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ir2 != null) {
      return ir2(this);
    }
    return orElse();
  }
}

abstract class _IR2 implements InterruptType {
  const factory _IR2() = _$_IR2;
}
