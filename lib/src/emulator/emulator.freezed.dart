// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'emulator.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$InterruptTypeTearOff {
  const _$InterruptTypeTearOff();

// ignore: unused_element
  _IR0 ir0() {
    return const _IR0();
  }

// ignore: unused_element
  _IR1 ir1() {
    return const _IR1();
  }

// ignore: unused_element
  _IR2 ir2() {
    return const _IR2();
  }
}

// ignore: unused_element
const $InterruptType = _$InterruptTypeTearOff();

mixin _$InterruptType {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result ir0(),
    @required Result ir1(),
    @required Result ir2(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result ir0(),
    Result ir1(),
    Result ir2(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result ir0(_IR0 value),
    @required Result ir1(_IR1 value),
    @required Result ir2(_IR2 value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result ir0(_IR0 value),
    Result ir1(_IR1 value),
    Result ir2(_IR2 value),
    @required Result orElse(),
  });
}

abstract class $InterruptTypeCopyWith<$Res> {
  factory $InterruptTypeCopyWith(
          InterruptType value, $Res Function(InterruptType) then) =
      _$InterruptTypeCopyWithImpl<$Res>;
}

class _$InterruptTypeCopyWithImpl<$Res>
    implements $InterruptTypeCopyWith<$Res> {
  _$InterruptTypeCopyWithImpl(this._value, this._then);

  final InterruptType _value;
  // ignore: unused_field
  final $Res Function(InterruptType) _then;
}

abstract class _$IR0CopyWith<$Res> {
  factory _$IR0CopyWith(_IR0 value, $Res Function(_IR0) then) =
      __$IR0CopyWithImpl<$Res>;
}

class __$IR0CopyWithImpl<$Res> extends _$InterruptTypeCopyWithImpl<$Res>
    implements _$IR0CopyWith<$Res> {
  __$IR0CopyWithImpl(_IR0 _value, $Res Function(_IR0) _then)
      : super(_value, (v) => _then(v as _IR0));

  @override
  _IR0 get _value => super._value as _IR0;
}

class _$_IR0 implements _IR0 {
  const _$_IR0();

  @override
  String toString() {
    return 'InterruptType.ir0()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _IR0);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result ir0(),
    @required Result ir1(),
    @required Result ir2(),
  }) {
    assert(ir0 != null);
    assert(ir1 != null);
    assert(ir2 != null);
    return ir0();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result ir0(),
    Result ir1(),
    Result ir2(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ir0 != null) {
      return ir0();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result ir0(_IR0 value),
    @required Result ir1(_IR1 value),
    @required Result ir2(_IR2 value),
  }) {
    assert(ir0 != null);
    assert(ir1 != null);
    assert(ir2 != null);
    return ir0(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result ir0(_IR0 value),
    Result ir1(_IR1 value),
    Result ir2(_IR2 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ir0 != null) {
      return ir0(this);
    }
    return orElse();
  }
}

abstract class _IR0 implements InterruptType {
  const factory _IR0() = _$_IR0;
}

abstract class _$IR1CopyWith<$Res> {
  factory _$IR1CopyWith(_IR1 value, $Res Function(_IR1) then) =
      __$IR1CopyWithImpl<$Res>;
}

class __$IR1CopyWithImpl<$Res> extends _$InterruptTypeCopyWithImpl<$Res>
    implements _$IR1CopyWith<$Res> {
  __$IR1CopyWithImpl(_IR1 _value, $Res Function(_IR1) _then)
      : super(_value, (v) => _then(v as _IR1));

  @override
  _IR1 get _value => super._value as _IR1;
}

class _$_IR1 implements _IR1 {
  const _$_IR1();

  @override
  String toString() {
    return 'InterruptType.ir1()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _IR1);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result ir0(),
    @required Result ir1(),
    @required Result ir2(),
  }) {
    assert(ir0 != null);
    assert(ir1 != null);
    assert(ir2 != null);
    return ir1();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result ir0(),
    Result ir1(),
    Result ir2(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ir1 != null) {
      return ir1();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result ir0(_IR0 value),
    @required Result ir1(_IR1 value),
    @required Result ir2(_IR2 value),
  }) {
    assert(ir0 != null);
    assert(ir1 != null);
    assert(ir2 != null);
    return ir1(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result ir0(_IR0 value),
    Result ir1(_IR1 value),
    Result ir2(_IR2 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ir1 != null) {
      return ir1(this);
    }
    return orElse();
  }
}

abstract class _IR1 implements InterruptType {
  const factory _IR1() = _$_IR1;
}

abstract class _$IR2CopyWith<$Res> {
  factory _$IR2CopyWith(_IR2 value, $Res Function(_IR2) then) =
      __$IR2CopyWithImpl<$Res>;
}

class __$IR2CopyWithImpl<$Res> extends _$InterruptTypeCopyWithImpl<$Res>
    implements _$IR2CopyWith<$Res> {
  __$IR2CopyWithImpl(_IR2 _value, $Res Function(_IR2) _then)
      : super(_value, (v) => _then(v as _IR2));

  @override
  _IR2 get _value => super._value as _IR2;
}

class _$_IR2 implements _IR2 {
  const _$_IR2();

  @override
  String toString() {
    return 'InterruptType.ir2()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _IR2);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result ir0(),
    @required Result ir1(),
    @required Result ir2(),
  }) {
    assert(ir0 != null);
    assert(ir1 != null);
    assert(ir2 != null);
    return ir2();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result ir0(),
    Result ir1(),
    Result ir2(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ir2 != null) {
      return ir2();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result ir0(_IR0 value),
    @required Result ir1(_IR1 value),
    @required Result ir2(_IR2 value),
  }) {
    assert(ir0 != null);
    assert(ir1 != null);
    assert(ir2 != null);
    return ir2(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result ir0(_IR0 value),
    Result ir1(_IR1 value),
    Result ir2(_IR2 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ir2 != null) {
      return ir2(this);
    }
    return orElse();
  }
}

abstract class _IR2 implements InterruptType {
  const factory _IR2() = _$_IR2;
}
