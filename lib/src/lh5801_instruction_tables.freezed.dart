// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies

part of 'lh5801_instruction_tables.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$InstructionCategoryTearOff {
  const _$InstructionCategoryTearOff();

// ignore: unused_element
  _Illegal illegal() {
    return const _Illegal();
  }

// ignore: unused_element
  _LogicalOperation logicalOperation() {
    return const _LogicalOperation();
  }

// ignore: unused_element
  _ComparisonBitTest comparisonBitTest() {
    return const _ComparisonBitTest();
  }

// ignore: unused_element
  _LoadStore loadStore() {
    return const _LoadStore();
  }

// ignore: unused_element
  _BlockTransferSearch blockTransferSearch() {
    return const _BlockTransferSearch();
  }

// ignore: unused_element
  _InputOutput inputOutput() {
    return const _InputOutput();
  }

// ignore: unused_element
  _Branch branch() {
    return const _Branch();
  }

// ignore: unused_element
  _Jump jump() {
    return const _Jump();
  }

// ignore: unused_element
  _Lop lop() {
    return const _Lop();
  }

// ignore: unused_element
  _Call call() {
    return const _Call();
  }

// ignore: unused_element
  _Return ret() {
    return const _Return();
  }
}

// ignore: unused_element
const $InstructionCategory = _$InstructionCategoryTearOff();

mixin _$InstructionCategory {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  });
}

abstract class $InstructionCategoryCopyWith<$Res> {
  factory $InstructionCategoryCopyWith(
          InstructionCategory value, $Res Function(InstructionCategory) then) =
      _$InstructionCategoryCopyWithImpl<$Res>;
}

class _$InstructionCategoryCopyWithImpl<$Res>
    implements $InstructionCategoryCopyWith<$Res> {
  _$InstructionCategoryCopyWithImpl(this._value, this._then);

  final InstructionCategory _value;
  // ignore: unused_field
  final $Res Function(InstructionCategory) _then;
}

abstract class _$IllegalCopyWith<$Res> {
  factory _$IllegalCopyWith(_Illegal value, $Res Function(_Illegal) then) =
      __$IllegalCopyWithImpl<$Res>;
}

class __$IllegalCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$IllegalCopyWith<$Res> {
  __$IllegalCopyWithImpl(_Illegal _value, $Res Function(_Illegal) _then)
      : super(_value, (v) => _then(v as _Illegal));

  @override
  _Illegal get _value => super._value as _Illegal;
}

class _$_Illegal implements _Illegal {
  const _$_Illegal();

  @override
  String toString() {
    return 'InstructionCategory.illegal()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Illegal);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return illegal();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (illegal != null) {
      return illegal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return illegal(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (illegal != null) {
      return illegal(this);
    }
    return orElse();
  }
}

abstract class _Illegal implements InstructionCategory {
  const factory _Illegal() = _$_Illegal;
}

abstract class _$LogicalOperationCopyWith<$Res> {
  factory _$LogicalOperationCopyWith(
          _LogicalOperation value, $Res Function(_LogicalOperation) then) =
      __$LogicalOperationCopyWithImpl<$Res>;
}

class __$LogicalOperationCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$LogicalOperationCopyWith<$Res> {
  __$LogicalOperationCopyWithImpl(
      _LogicalOperation _value, $Res Function(_LogicalOperation) _then)
      : super(_value, (v) => _then(v as _LogicalOperation));

  @override
  _LogicalOperation get _value => super._value as _LogicalOperation;
}

class _$_LogicalOperation implements _LogicalOperation {
  const _$_LogicalOperation();

  @override
  String toString() {
    return 'InstructionCategory.logicalOperation()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LogicalOperation);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return logicalOperation();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (logicalOperation != null) {
      return logicalOperation();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return logicalOperation(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (logicalOperation != null) {
      return logicalOperation(this);
    }
    return orElse();
  }
}

abstract class _LogicalOperation implements InstructionCategory {
  const factory _LogicalOperation() = _$_LogicalOperation;
}

abstract class _$ComparisonBitTestCopyWith<$Res> {
  factory _$ComparisonBitTestCopyWith(
          _ComparisonBitTest value, $Res Function(_ComparisonBitTest) then) =
      __$ComparisonBitTestCopyWithImpl<$Res>;
}

class __$ComparisonBitTestCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$ComparisonBitTestCopyWith<$Res> {
  __$ComparisonBitTestCopyWithImpl(
      _ComparisonBitTest _value, $Res Function(_ComparisonBitTest) _then)
      : super(_value, (v) => _then(v as _ComparisonBitTest));

  @override
  _ComparisonBitTest get _value => super._value as _ComparisonBitTest;
}

class _$_ComparisonBitTest implements _ComparisonBitTest {
  const _$_ComparisonBitTest();

  @override
  String toString() {
    return 'InstructionCategory.comparisonBitTest()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _ComparisonBitTest);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return comparisonBitTest();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (comparisonBitTest != null) {
      return comparisonBitTest();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return comparisonBitTest(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (comparisonBitTest != null) {
      return comparisonBitTest(this);
    }
    return orElse();
  }
}

abstract class _ComparisonBitTest implements InstructionCategory {
  const factory _ComparisonBitTest() = _$_ComparisonBitTest;
}

abstract class _$LoadStoreCopyWith<$Res> {
  factory _$LoadStoreCopyWith(
          _LoadStore value, $Res Function(_LoadStore) then) =
      __$LoadStoreCopyWithImpl<$Res>;
}

class __$LoadStoreCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$LoadStoreCopyWith<$Res> {
  __$LoadStoreCopyWithImpl(_LoadStore _value, $Res Function(_LoadStore) _then)
      : super(_value, (v) => _then(v as _LoadStore));

  @override
  _LoadStore get _value => super._value as _LoadStore;
}

class _$_LoadStore implements _LoadStore {
  const _$_LoadStore();

  @override
  String toString() {
    return 'InstructionCategory.loadStore()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LoadStore);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return loadStore();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadStore != null) {
      return loadStore();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return loadStore(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (loadStore != null) {
      return loadStore(this);
    }
    return orElse();
  }
}

abstract class _LoadStore implements InstructionCategory {
  const factory _LoadStore() = _$_LoadStore;
}

abstract class _$BlockTransferSearchCopyWith<$Res> {
  factory _$BlockTransferSearchCopyWith(_BlockTransferSearch value,
          $Res Function(_BlockTransferSearch) then) =
      __$BlockTransferSearchCopyWithImpl<$Res>;
}

class __$BlockTransferSearchCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$BlockTransferSearchCopyWith<$Res> {
  __$BlockTransferSearchCopyWithImpl(
      _BlockTransferSearch _value, $Res Function(_BlockTransferSearch) _then)
      : super(_value, (v) => _then(v as _BlockTransferSearch));

  @override
  _BlockTransferSearch get _value => super._value as _BlockTransferSearch;
}

class _$_BlockTransferSearch implements _BlockTransferSearch {
  const _$_BlockTransferSearch();

  @override
  String toString() {
    return 'InstructionCategory.blockTransferSearch()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _BlockTransferSearch);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return blockTransferSearch();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (blockTransferSearch != null) {
      return blockTransferSearch();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return blockTransferSearch(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (blockTransferSearch != null) {
      return blockTransferSearch(this);
    }
    return orElse();
  }
}

abstract class _BlockTransferSearch implements InstructionCategory {
  const factory _BlockTransferSearch() = _$_BlockTransferSearch;
}

abstract class _$InputOutputCopyWith<$Res> {
  factory _$InputOutputCopyWith(
          _InputOutput value, $Res Function(_InputOutput) then) =
      __$InputOutputCopyWithImpl<$Res>;
}

class __$InputOutputCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$InputOutputCopyWith<$Res> {
  __$InputOutputCopyWithImpl(
      _InputOutput _value, $Res Function(_InputOutput) _then)
      : super(_value, (v) => _then(v as _InputOutput));

  @override
  _InputOutput get _value => super._value as _InputOutput;
}

class _$_InputOutput implements _InputOutput {
  const _$_InputOutput();

  @override
  String toString() {
    return 'InstructionCategory.inputOutput()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _InputOutput);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return inputOutput();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (inputOutput != null) {
      return inputOutput();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return inputOutput(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (inputOutput != null) {
      return inputOutput(this);
    }
    return orElse();
  }
}

abstract class _InputOutput implements InstructionCategory {
  const factory _InputOutput() = _$_InputOutput;
}

abstract class _$BranchCopyWith<$Res> {
  factory _$BranchCopyWith(_Branch value, $Res Function(_Branch) then) =
      __$BranchCopyWithImpl<$Res>;
}

class __$BranchCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$BranchCopyWith<$Res> {
  __$BranchCopyWithImpl(_Branch _value, $Res Function(_Branch) _then)
      : super(_value, (v) => _then(v as _Branch));

  @override
  _Branch get _value => super._value as _Branch;
}

class _$_Branch implements _Branch {
  const _$_Branch();

  @override
  String toString() {
    return 'InstructionCategory.branch()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Branch);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return branch();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (branch != null) {
      return branch();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return branch(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (branch != null) {
      return branch(this);
    }
    return orElse();
  }
}

abstract class _Branch implements InstructionCategory {
  const factory _Branch() = _$_Branch;
}

abstract class _$JumpCopyWith<$Res> {
  factory _$JumpCopyWith(_Jump value, $Res Function(_Jump) then) =
      __$JumpCopyWithImpl<$Res>;
}

class __$JumpCopyWithImpl<$Res> extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$JumpCopyWith<$Res> {
  __$JumpCopyWithImpl(_Jump _value, $Res Function(_Jump) _then)
      : super(_value, (v) => _then(v as _Jump));

  @override
  _Jump get _value => super._value as _Jump;
}

class _$_Jump implements _Jump {
  const _$_Jump();

  @override
  String toString() {
    return 'InstructionCategory.jump()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Jump);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return jump();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (jump != null) {
      return jump();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return jump(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (jump != null) {
      return jump(this);
    }
    return orElse();
  }
}

abstract class _Jump implements InstructionCategory {
  const factory _Jump() = _$_Jump;
}

abstract class _$LopCopyWith<$Res> {
  factory _$LopCopyWith(_Lop value, $Res Function(_Lop) then) =
      __$LopCopyWithImpl<$Res>;
}

class __$LopCopyWithImpl<$Res> extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$LopCopyWith<$Res> {
  __$LopCopyWithImpl(_Lop _value, $Res Function(_Lop) _then)
      : super(_value, (v) => _then(v as _Lop));

  @override
  _Lop get _value => super._value as _Lop;
}

class _$_Lop implements _Lop {
  const _$_Lop();

  @override
  String toString() {
    return 'InstructionCategory.lop()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Lop);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return lop();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (lop != null) {
      return lop();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return lop(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (lop != null) {
      return lop(this);
    }
    return orElse();
  }
}

abstract class _Lop implements InstructionCategory {
  const factory _Lop() = _$_Lop;
}

abstract class _$CallCopyWith<$Res> {
  factory _$CallCopyWith(_Call value, $Res Function(_Call) then) =
      __$CallCopyWithImpl<$Res>;
}

class __$CallCopyWithImpl<$Res> extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$CallCopyWith<$Res> {
  __$CallCopyWithImpl(_Call _value, $Res Function(_Call) _then)
      : super(_value, (v) => _then(v as _Call));

  @override
  _Call get _value => super._value as _Call;
}

class _$_Call implements _Call {
  const _$_Call();

  @override
  String toString() {
    return 'InstructionCategory.call()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Call);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return call();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (call != null) {
      return call();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return call(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (call != null) {
      return call(this);
    }
    return orElse();
  }
}

abstract class _Call implements InstructionCategory {
  const factory _Call() = _$_Call;
}

abstract class _$ReturnCopyWith<$Res> {
  factory _$ReturnCopyWith(_Return value, $Res Function(_Return) then) =
      __$ReturnCopyWithImpl<$Res>;
}

class __$ReturnCopyWithImpl<$Res>
    extends _$InstructionCategoryCopyWithImpl<$Res>
    implements _$ReturnCopyWith<$Res> {
  __$ReturnCopyWithImpl(_Return _value, $Res Function(_Return) _then)
      : super(_value, (v) => _then(v as _Return));

  @override
  _Return get _value => super._value as _Return;
}

class _$_Return implements _Return {
  const _$_Return();

  @override
  String toString() {
    return 'InstructionCategory.ret()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Return);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result illegal(),
    @required Result logicalOperation(),
    @required Result comparisonBitTest(),
    @required Result loadStore(),
    @required Result blockTransferSearch(),
    @required Result inputOutput(),
    @required Result branch(),
    @required Result jump(),
    @required Result lop(),
    @required Result call(),
    @required Result ret(),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return ret();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result illegal(),
    Result logicalOperation(),
    Result comparisonBitTest(),
    Result loadStore(),
    Result blockTransferSearch(),
    Result inputOutput(),
    Result branch(),
    Result jump(),
    Result lop(),
    Result call(),
    Result ret(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ret != null) {
      return ret();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result illegal(_Illegal value),
    @required Result logicalOperation(_LogicalOperation value),
    @required Result comparisonBitTest(_ComparisonBitTest value),
    @required Result loadStore(_LoadStore value),
    @required Result blockTransferSearch(_BlockTransferSearch value),
    @required Result inputOutput(_InputOutput value),
    @required Result branch(_Branch value),
    @required Result jump(_Jump value),
    @required Result lop(_Lop value),
    @required Result call(_Call value),
    @required Result ret(_Return value),
  }) {
    assert(illegal != null);
    assert(logicalOperation != null);
    assert(comparisonBitTest != null);
    assert(loadStore != null);
    assert(blockTransferSearch != null);
    assert(inputOutput != null);
    assert(branch != null);
    assert(jump != null);
    assert(lop != null);
    assert(call != null);
    assert(ret != null);
    return ret(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result illegal(_Illegal value),
    Result logicalOperation(_LogicalOperation value),
    Result comparisonBitTest(_ComparisonBitTest value),
    Result loadStore(_LoadStore value),
    Result blockTransferSearch(_BlockTransferSearch value),
    Result inputOutput(_InputOutput value),
    Result branch(_Branch value),
    Result jump(_Jump value),
    Result lop(_Lop value),
    Result call(_Call value),
    Result ret(_Return value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (ret != null) {
      return ret(this);
    }
    return orElse();
  }
}

abstract class _Return implements InstructionCategory {
  const factory _Return() = _$_Return;
}

class _$OperandTypeTearOff {
  const _$OperandTypeTearOff();

// ignore: unused_element
  _None none() {
    return const _None();
  }

// ignore: unused_element
  _Reg reg() {
    return const _Reg();
  }

// ignore: unused_element
  _Mem0Reg mem0Reg() {
    return const _Mem0Reg();
  }

// ignore: unused_element
  _Mem0Imm16 mem0Imm16() {
    return const _Mem0Imm16();
  }

// ignore: unused_element
  _Mem1Reg mem1Reg() {
    return const _Mem1Reg();
  }

// ignore: unused_element
  _Mem1Imm16 mem1Imm16() {
    return const _Mem1Imm16();
  }

// ignore: unused_element
  _Imm8 imm8() {
    return const _Imm8();
  }

// ignore: unused_element
  _DispPlus dispPlus() {
    return const _DispPlus();
  }

// ignore: unused_element
  _DispMinus dispMinus() {
    return const _DispMinus();
  }

// ignore: unused_element
  _Mem0Imm8 mem0Imm8() {
    return const _Mem0Imm8();
  }

// ignore: unused_element
  _Imm16 imm16() {
    return const _Imm16();
  }
}

// ignore: unused_element
const $OperandType = _$OperandTypeTearOff();

mixin _$OperandType {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(),
    @required Result mem0Reg(),
    @required Result mem0Imm16(),
    @required Result mem1Reg(),
    @required Result mem1Imm16(),
    @required Result imm8(),
    @required Result dispPlus(),
    @required Result dispMinus(),
    @required Result mem0Imm8(),
    @required Result imm16(),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(),
    Result mem0Reg(),
    Result mem0Imm16(),
    Result mem1Reg(),
    Result mem1Imm16(),
    Result imm8(),
    Result dispPlus(),
    Result dispMinus(),
    Result mem0Imm8(),
    Result imm16(),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Imm8(_Mem0Imm8 value),
    @required Result imm16(_Imm16 value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Imm8(_Mem0Imm8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  });
}

abstract class $OperandTypeCopyWith<$Res> {
  factory $OperandTypeCopyWith(
          OperandType value, $Res Function(OperandType) then) =
      _$OperandTypeCopyWithImpl<$Res>;
}

class _$OperandTypeCopyWithImpl<$Res> implements $OperandTypeCopyWith<$Res> {
  _$OperandTypeCopyWithImpl(this._value, this._then);

  final OperandType _value;
  // ignore: unused_field
  final $Res Function(OperandType) _then;
}

abstract class _$NoneCopyWith<$Res> {
  factory _$NoneCopyWith(_None value, $Res Function(_None) then) =
      __$NoneCopyWithImpl<$Res>;
}

class __$NoneCopyWithImpl<$Res> extends _$OperandTypeCopyWithImpl<$Res>
    implements _$NoneCopyWith<$Res> {
  __$NoneCopyWithImpl(_None _value, $Res Function(_None) _then)
      : super(_value, (v) => _then(v as _None));

  @override
  _None get _value => super._value as _None;
}

class _$_None implements _None {
  const _$_None();

  @override
  String toString() {
    return 'OperandType.none()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _None);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(),
    @required Result mem0Reg(),
    @required Result mem0Imm16(),
    @required Result mem1Reg(),
    @required Result mem1Imm16(),
    @required Result imm8(),
    @required Result dispPlus(),
    @required Result dispMinus(),
    @required Result mem0Imm8(),
    @required Result imm16(),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return none();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(),
    Result mem0Reg(),
    Result mem0Imm16(),
    Result mem1Reg(),
    Result mem1Imm16(),
    Result imm8(),
    Result dispPlus(),
    Result dispMinus(),
    Result mem0Imm8(),
    Result imm16(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (none != null) {
      return none();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Imm8(_Mem0Imm8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return none(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Imm8(_Mem0Imm8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (none != null) {
      return none(this);
    }
    return orElse();
  }
}

abstract class _None implements OperandType {
  const factory _None() = _$_None;
}

abstract class _$RegCopyWith<$Res> {
  factory _$RegCopyWith(_Reg value, $Res Function(_Reg) then) =
      __$RegCopyWithImpl<$Res>;
}

class __$RegCopyWithImpl<$Res> extends _$OperandTypeCopyWithImpl<$Res>
    implements _$RegCopyWith<$Res> {
  __$RegCopyWithImpl(_Reg _value, $Res Function(_Reg) _then)
      : super(_value, (v) => _then(v as _Reg));

  @override
  _Reg get _value => super._value as _Reg;
}

class _$_Reg implements _Reg {
  const _$_Reg();

  @override
  String toString() {
    return 'OperandType.reg()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Reg);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(),
    @required Result mem0Reg(),
    @required Result mem0Imm16(),
    @required Result mem1Reg(),
    @required Result mem1Imm16(),
    @required Result imm8(),
    @required Result dispPlus(),
    @required Result dispMinus(),
    @required Result mem0Imm8(),
    @required Result imm16(),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return reg();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(),
    Result mem0Reg(),
    Result mem0Imm16(),
    Result mem1Reg(),
    Result mem1Imm16(),
    Result imm8(),
    Result dispPlus(),
    Result dispMinus(),
    Result mem0Imm8(),
    Result imm16(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (reg != null) {
      return reg();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Imm8(_Mem0Imm8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return reg(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Imm8(_Mem0Imm8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (reg != null) {
      return reg(this);
    }
    return orElse();
  }
}

abstract class _Reg implements OperandType {
  const factory _Reg() = _$_Reg;
}

abstract class _$Mem0RegCopyWith<$Res> {
  factory _$Mem0RegCopyWith(_Mem0Reg value, $Res Function(_Mem0Reg) then) =
      __$Mem0RegCopyWithImpl<$Res>;
}

class __$Mem0RegCopyWithImpl<$Res> extends _$OperandTypeCopyWithImpl<$Res>
    implements _$Mem0RegCopyWith<$Res> {
  __$Mem0RegCopyWithImpl(_Mem0Reg _value, $Res Function(_Mem0Reg) _then)
      : super(_value, (v) => _then(v as _Mem0Reg));

  @override
  _Mem0Reg get _value => super._value as _Mem0Reg;
}

class _$_Mem0Reg implements _Mem0Reg {
  const _$_Mem0Reg();

  @override
  String toString() {
    return 'OperandType.mem0Reg()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Mem0Reg);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(),
    @required Result mem0Reg(),
    @required Result mem0Imm16(),
    @required Result mem1Reg(),
    @required Result mem1Imm16(),
    @required Result imm8(),
    @required Result dispPlus(),
    @required Result dispMinus(),
    @required Result mem0Imm8(),
    @required Result imm16(),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return mem0Reg();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(),
    Result mem0Reg(),
    Result mem0Imm16(),
    Result mem1Reg(),
    Result mem1Imm16(),
    Result imm8(),
    Result dispPlus(),
    Result dispMinus(),
    Result mem0Imm8(),
    Result imm16(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem0Reg != null) {
      return mem0Reg();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Imm8(_Mem0Imm8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return mem0Reg(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Imm8(_Mem0Imm8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem0Reg != null) {
      return mem0Reg(this);
    }
    return orElse();
  }
}

abstract class _Mem0Reg implements OperandType {
  const factory _Mem0Reg() = _$_Mem0Reg;
}

abstract class _$Mem0Imm16CopyWith<$Res> {
  factory _$Mem0Imm16CopyWith(
          _Mem0Imm16 value, $Res Function(_Mem0Imm16) then) =
      __$Mem0Imm16CopyWithImpl<$Res>;
}

class __$Mem0Imm16CopyWithImpl<$Res> extends _$OperandTypeCopyWithImpl<$Res>
    implements _$Mem0Imm16CopyWith<$Res> {
  __$Mem0Imm16CopyWithImpl(_Mem0Imm16 _value, $Res Function(_Mem0Imm16) _then)
      : super(_value, (v) => _then(v as _Mem0Imm16));

  @override
  _Mem0Imm16 get _value => super._value as _Mem0Imm16;
}

class _$_Mem0Imm16 implements _Mem0Imm16 {
  const _$_Mem0Imm16();

  @override
  String toString() {
    return 'OperandType.mem0Imm16()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Mem0Imm16);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(),
    @required Result mem0Reg(),
    @required Result mem0Imm16(),
    @required Result mem1Reg(),
    @required Result mem1Imm16(),
    @required Result imm8(),
    @required Result dispPlus(),
    @required Result dispMinus(),
    @required Result mem0Imm8(),
    @required Result imm16(),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return mem0Imm16();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(),
    Result mem0Reg(),
    Result mem0Imm16(),
    Result mem1Reg(),
    Result mem1Imm16(),
    Result imm8(),
    Result dispPlus(),
    Result dispMinus(),
    Result mem0Imm8(),
    Result imm16(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem0Imm16 != null) {
      return mem0Imm16();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Imm8(_Mem0Imm8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return mem0Imm16(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Imm8(_Mem0Imm8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem0Imm16 != null) {
      return mem0Imm16(this);
    }
    return orElse();
  }
}

abstract class _Mem0Imm16 implements OperandType {
  const factory _Mem0Imm16() = _$_Mem0Imm16;
}

abstract class _$Mem1RegCopyWith<$Res> {
  factory _$Mem1RegCopyWith(_Mem1Reg value, $Res Function(_Mem1Reg) then) =
      __$Mem1RegCopyWithImpl<$Res>;
}

class __$Mem1RegCopyWithImpl<$Res> extends _$OperandTypeCopyWithImpl<$Res>
    implements _$Mem1RegCopyWith<$Res> {
  __$Mem1RegCopyWithImpl(_Mem1Reg _value, $Res Function(_Mem1Reg) _then)
      : super(_value, (v) => _then(v as _Mem1Reg));

  @override
  _Mem1Reg get _value => super._value as _Mem1Reg;
}

class _$_Mem1Reg implements _Mem1Reg {
  const _$_Mem1Reg();

  @override
  String toString() {
    return 'OperandType.mem1Reg()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Mem1Reg);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(),
    @required Result mem0Reg(),
    @required Result mem0Imm16(),
    @required Result mem1Reg(),
    @required Result mem1Imm16(),
    @required Result imm8(),
    @required Result dispPlus(),
    @required Result dispMinus(),
    @required Result mem0Imm8(),
    @required Result imm16(),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return mem1Reg();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(),
    Result mem0Reg(),
    Result mem0Imm16(),
    Result mem1Reg(),
    Result mem1Imm16(),
    Result imm8(),
    Result dispPlus(),
    Result dispMinus(),
    Result mem0Imm8(),
    Result imm16(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem1Reg != null) {
      return mem1Reg();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Imm8(_Mem0Imm8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return mem1Reg(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Imm8(_Mem0Imm8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem1Reg != null) {
      return mem1Reg(this);
    }
    return orElse();
  }
}

abstract class _Mem1Reg implements OperandType {
  const factory _Mem1Reg() = _$_Mem1Reg;
}

abstract class _$Mem1Imm16CopyWith<$Res> {
  factory _$Mem1Imm16CopyWith(
          _Mem1Imm16 value, $Res Function(_Mem1Imm16) then) =
      __$Mem1Imm16CopyWithImpl<$Res>;
}

class __$Mem1Imm16CopyWithImpl<$Res> extends _$OperandTypeCopyWithImpl<$Res>
    implements _$Mem1Imm16CopyWith<$Res> {
  __$Mem1Imm16CopyWithImpl(_Mem1Imm16 _value, $Res Function(_Mem1Imm16) _then)
      : super(_value, (v) => _then(v as _Mem1Imm16));

  @override
  _Mem1Imm16 get _value => super._value as _Mem1Imm16;
}

class _$_Mem1Imm16 implements _Mem1Imm16 {
  const _$_Mem1Imm16();

  @override
  String toString() {
    return 'OperandType.mem1Imm16()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Mem1Imm16);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(),
    @required Result mem0Reg(),
    @required Result mem0Imm16(),
    @required Result mem1Reg(),
    @required Result mem1Imm16(),
    @required Result imm8(),
    @required Result dispPlus(),
    @required Result dispMinus(),
    @required Result mem0Imm8(),
    @required Result imm16(),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return mem1Imm16();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(),
    Result mem0Reg(),
    Result mem0Imm16(),
    Result mem1Reg(),
    Result mem1Imm16(),
    Result imm8(),
    Result dispPlus(),
    Result dispMinus(),
    Result mem0Imm8(),
    Result imm16(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem1Imm16 != null) {
      return mem1Imm16();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Imm8(_Mem0Imm8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return mem1Imm16(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Imm8(_Mem0Imm8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem1Imm16 != null) {
      return mem1Imm16(this);
    }
    return orElse();
  }
}

abstract class _Mem1Imm16 implements OperandType {
  const factory _Mem1Imm16() = _$_Mem1Imm16;
}

abstract class _$Imm8CopyWith<$Res> {
  factory _$Imm8CopyWith(_Imm8 value, $Res Function(_Imm8) then) =
      __$Imm8CopyWithImpl<$Res>;
}

class __$Imm8CopyWithImpl<$Res> extends _$OperandTypeCopyWithImpl<$Res>
    implements _$Imm8CopyWith<$Res> {
  __$Imm8CopyWithImpl(_Imm8 _value, $Res Function(_Imm8) _then)
      : super(_value, (v) => _then(v as _Imm8));

  @override
  _Imm8 get _value => super._value as _Imm8;
}

class _$_Imm8 implements _Imm8 {
  const _$_Imm8();

  @override
  String toString() {
    return 'OperandType.imm8()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Imm8);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(),
    @required Result mem0Reg(),
    @required Result mem0Imm16(),
    @required Result mem1Reg(),
    @required Result mem1Imm16(),
    @required Result imm8(),
    @required Result dispPlus(),
    @required Result dispMinus(),
    @required Result mem0Imm8(),
    @required Result imm16(),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return imm8();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(),
    Result mem0Reg(),
    Result mem0Imm16(),
    Result mem1Reg(),
    Result mem1Imm16(),
    Result imm8(),
    Result dispPlus(),
    Result dispMinus(),
    Result mem0Imm8(),
    Result imm16(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (imm8 != null) {
      return imm8();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Imm8(_Mem0Imm8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return imm8(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Imm8(_Mem0Imm8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (imm8 != null) {
      return imm8(this);
    }
    return orElse();
  }
}

abstract class _Imm8 implements OperandType {
  const factory _Imm8() = _$_Imm8;
}

abstract class _$DispPlusCopyWith<$Res> {
  factory _$DispPlusCopyWith(_DispPlus value, $Res Function(_DispPlus) then) =
      __$DispPlusCopyWithImpl<$Res>;
}

class __$DispPlusCopyWithImpl<$Res> extends _$OperandTypeCopyWithImpl<$Res>
    implements _$DispPlusCopyWith<$Res> {
  __$DispPlusCopyWithImpl(_DispPlus _value, $Res Function(_DispPlus) _then)
      : super(_value, (v) => _then(v as _DispPlus));

  @override
  _DispPlus get _value => super._value as _DispPlus;
}

class _$_DispPlus implements _DispPlus {
  const _$_DispPlus();

  @override
  String toString() {
    return 'OperandType.dispPlus()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _DispPlus);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(),
    @required Result mem0Reg(),
    @required Result mem0Imm16(),
    @required Result mem1Reg(),
    @required Result mem1Imm16(),
    @required Result imm8(),
    @required Result dispPlus(),
    @required Result dispMinus(),
    @required Result mem0Imm8(),
    @required Result imm16(),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return dispPlus();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(),
    Result mem0Reg(),
    Result mem0Imm16(),
    Result mem1Reg(),
    Result mem1Imm16(),
    Result imm8(),
    Result dispPlus(),
    Result dispMinus(),
    Result mem0Imm8(),
    Result imm16(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (dispPlus != null) {
      return dispPlus();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Imm8(_Mem0Imm8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return dispPlus(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Imm8(_Mem0Imm8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (dispPlus != null) {
      return dispPlus(this);
    }
    return orElse();
  }
}

abstract class _DispPlus implements OperandType {
  const factory _DispPlus() = _$_DispPlus;
}

abstract class _$DispMinusCopyWith<$Res> {
  factory _$DispMinusCopyWith(
          _DispMinus value, $Res Function(_DispMinus) then) =
      __$DispMinusCopyWithImpl<$Res>;
}

class __$DispMinusCopyWithImpl<$Res> extends _$OperandTypeCopyWithImpl<$Res>
    implements _$DispMinusCopyWith<$Res> {
  __$DispMinusCopyWithImpl(_DispMinus _value, $Res Function(_DispMinus) _then)
      : super(_value, (v) => _then(v as _DispMinus));

  @override
  _DispMinus get _value => super._value as _DispMinus;
}

class _$_DispMinus implements _DispMinus {
  const _$_DispMinus();

  @override
  String toString() {
    return 'OperandType.dispMinus()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _DispMinus);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(),
    @required Result mem0Reg(),
    @required Result mem0Imm16(),
    @required Result mem1Reg(),
    @required Result mem1Imm16(),
    @required Result imm8(),
    @required Result dispPlus(),
    @required Result dispMinus(),
    @required Result mem0Imm8(),
    @required Result imm16(),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return dispMinus();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(),
    Result mem0Reg(),
    Result mem0Imm16(),
    Result mem1Reg(),
    Result mem1Imm16(),
    Result imm8(),
    Result dispPlus(),
    Result dispMinus(),
    Result mem0Imm8(),
    Result imm16(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (dispMinus != null) {
      return dispMinus();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Imm8(_Mem0Imm8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return dispMinus(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Imm8(_Mem0Imm8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (dispMinus != null) {
      return dispMinus(this);
    }
    return orElse();
  }
}

abstract class _DispMinus implements OperandType {
  const factory _DispMinus() = _$_DispMinus;
}

abstract class _$Mem0Imm8CopyWith<$Res> {
  factory _$Mem0Imm8CopyWith(_Mem0Imm8 value, $Res Function(_Mem0Imm8) then) =
      __$Mem0Imm8CopyWithImpl<$Res>;
}

class __$Mem0Imm8CopyWithImpl<$Res> extends _$OperandTypeCopyWithImpl<$Res>
    implements _$Mem0Imm8CopyWith<$Res> {
  __$Mem0Imm8CopyWithImpl(_Mem0Imm8 _value, $Res Function(_Mem0Imm8) _then)
      : super(_value, (v) => _then(v as _Mem0Imm8));

  @override
  _Mem0Imm8 get _value => super._value as _Mem0Imm8;
}

class _$_Mem0Imm8 implements _Mem0Imm8 {
  const _$_Mem0Imm8();

  @override
  String toString() {
    return 'OperandType.mem0Imm8()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Mem0Imm8);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(),
    @required Result mem0Reg(),
    @required Result mem0Imm16(),
    @required Result mem1Reg(),
    @required Result mem1Imm16(),
    @required Result imm8(),
    @required Result dispPlus(),
    @required Result dispMinus(),
    @required Result mem0Imm8(),
    @required Result imm16(),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return mem0Imm8();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(),
    Result mem0Reg(),
    Result mem0Imm16(),
    Result mem1Reg(),
    Result mem1Imm16(),
    Result imm8(),
    Result dispPlus(),
    Result dispMinus(),
    Result mem0Imm8(),
    Result imm16(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem0Imm8 != null) {
      return mem0Imm8();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Imm8(_Mem0Imm8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return mem0Imm8(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Imm8(_Mem0Imm8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (mem0Imm8 != null) {
      return mem0Imm8(this);
    }
    return orElse();
  }
}

abstract class _Mem0Imm8 implements OperandType {
  const factory _Mem0Imm8() = _$_Mem0Imm8;
}

abstract class _$Imm16CopyWith<$Res> {
  factory _$Imm16CopyWith(_Imm16 value, $Res Function(_Imm16) then) =
      __$Imm16CopyWithImpl<$Res>;
}

class __$Imm16CopyWithImpl<$Res> extends _$OperandTypeCopyWithImpl<$Res>
    implements _$Imm16CopyWith<$Res> {
  __$Imm16CopyWithImpl(_Imm16 _value, $Res Function(_Imm16) _then)
      : super(_value, (v) => _then(v as _Imm16));

  @override
  _Imm16 get _value => super._value as _Imm16;
}

class _$_Imm16 implements _Imm16 {
  const _$_Imm16();

  @override
  String toString() {
    return 'OperandType.imm16()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _Imm16);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result none(),
    @required Result reg(),
    @required Result mem0Reg(),
    @required Result mem0Imm16(),
    @required Result mem1Reg(),
    @required Result mem1Imm16(),
    @required Result imm8(),
    @required Result dispPlus(),
    @required Result dispMinus(),
    @required Result mem0Imm8(),
    @required Result imm16(),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return imm16();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result none(),
    Result reg(),
    Result mem0Reg(),
    Result mem0Imm16(),
    Result mem1Reg(),
    Result mem1Imm16(),
    Result imm8(),
    Result dispPlus(),
    Result dispMinus(),
    Result mem0Imm8(),
    Result imm16(),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (imm16 != null) {
      return imm16();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result none(_None value),
    @required Result reg(_Reg value),
    @required Result mem0Reg(_Mem0Reg value),
    @required Result mem0Imm16(_Mem0Imm16 value),
    @required Result mem1Reg(_Mem1Reg value),
    @required Result mem1Imm16(_Mem1Imm16 value),
    @required Result imm8(_Imm8 value),
    @required Result dispPlus(_DispPlus value),
    @required Result dispMinus(_DispMinus value),
    @required Result mem0Imm8(_Mem0Imm8 value),
    @required Result imm16(_Imm16 value),
  }) {
    assert(none != null);
    assert(reg != null);
    assert(mem0Reg != null);
    assert(mem0Imm16 != null);
    assert(mem1Reg != null);
    assert(mem1Imm16 != null);
    assert(imm8 != null);
    assert(dispPlus != null);
    assert(dispMinus != null);
    assert(mem0Imm8 != null);
    assert(imm16 != null);
    return imm16(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result none(_None value),
    Result reg(_Reg value),
    Result mem0Reg(_Mem0Reg value),
    Result mem0Imm16(_Mem0Imm16 value),
    Result mem1Reg(_Mem1Reg value),
    Result mem1Imm16(_Mem1Imm16 value),
    Result imm8(_Imm8 value),
    Result dispPlus(_DispPlus value),
    Result dispMinus(_DispMinus value),
    Result mem0Imm8(_Mem0Imm8 value),
    Result imm16(_Imm16 value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (imm16 != null) {
      return imm16(this);
    }
    return orElse();
  }
}

abstract class _Imm16 implements OperandType {
  const factory _Imm16() = _$_Imm16;
}
